# Python Security Learning—Django SQL Injection Vulnerability

Author: H3rmesk1t

Data: 2022.06.01

# Preface
Before the exam, I saw the SQL injection vulnerability of `Django` when I flipped the component vulnerability of `Python`. After the exam, I took time to analyze several related vulnerabilities, namely `CVE-2020-7471`, `CVE-2021-35042` and `CVE-2022-28346`.


# Django Introduction
Django is a high-level Python web framework that encourages rapid development and clean, pragmatic design. Built by experienced developers, it takes care of much of the hassle of web development, so you can focus on writing your app without needing to reinvent the wheel. It’s free and open source.

<div align=center><img src="./images/1.png"></div>

# CVE-2020-7471
## Vulnerability Introduction
Django 1.11 before 1.11.28, 2.2 before 2.2.10, and 3.0 before 3.0.3 allows SQL Injection if untrusted data is used as a StringAgg delimiter (e.g., in Django applications that offer downloads of data as a series of rows with a user-specified column delimiter). By passing a suitably crafted delimiter to a contrib.postgres.aggregates.StringAgg instance, it was possible to break escaping and inject malicious SQL.

<div align=center><img src="./images/2.png"></div>

## Vulnerability Environment
 - Reference to the built environment [CVE-2020-7471](https://github.com/H3rmesk1t/Django-SQL-Inject-Env/tree/main/CVE-2020-7471).

## Vulnerability Analysis
In the vulnerability description, the core of the vulnerability is that the delimiter parameter of the `StringAgg` aggregate function has a `SQL` injection vulnerability. By looking for the `commit` record of `Django`, it can be seen in the official pair's fix code that the vulnerability function is located in the `from django.contrib.postgres.aggregates import StringAgg` module.

<div align=center><img src="./images/3.png"></div>

Official fixes to defend against this injection vulnerability by introducing `Value` from `from django.db.models import Value`:

```python
delimiter_expr = Value(str(delimiter))
```

Follow up on the `Value` function in `django.db.models`. As you can see in the comments, the `Value` function will add the processed parameters to the `sql parameter list`, and then filter the built-in filtering mechanism of `Django` to prevent `sql` injection vulnerabilities.

<div align=center><img src="./images/4.png"></div>

Since the vulnerability point is located in the `Delimiter` parameter of the `StringAgg` aggregation function, the aggregation function is explained in the official documentation. In short, it will cascade the input values ​​using the `delimiter` delimiter.

<div align=center><img src="./images/5.png"></div>

When `Fuzz` is found to be single quotes, an error will be raised. You can see through the printed error message that the single quotes are embedded in the `sql` statement without any escape.

```python
def fuzz():
    symbol_str = "!@#$%^&*()_+=-|\\\"':;?/>.<,{}[]"
    for c in symbol_str:
        results = Info.objects.all().values('gender').annotate(mydefinedname=StringAgg('name',delimiter=c))
        try:
            for e in results:
                pass
        except IndexError:
            pass
        except Exception as err:
            print("[+] error message: ", err)
            print("[+] vulnerability separator: ", c)
```

<div align=center><img src="./images/6.png"></div>

According to the error message, break the point in the `_execute` function.

<div align=center><img src="./images/7.png"></div>

After traversing the data in the database, perform the `Fuzz` operation and observe the `sql` with `delimiter` added as single quotes.

<div align=center><img src="./images/8.png"></div>

Since `sql` is a string at this time, an escape number will be generated. The execution statement of the `sql` statement in `postgres` is:

```postgres
SELECT "vuln_app_info"."gender", STRING_AGG("vuln_app_info"."name", ''') AS "mydefinedname" FROM "vuln_app_info" GROUP BY "vuln_app_info"."gender"
```

Then try setting `delimiter` to `')--` so that it comments out the following statement and checks the error message. You can see that the `FROM` statement has been successfully commented.

<div align=center><img src="./images/9.png"></div>

The `exp` is constructed as follows:

```python
-\') AS "demoname" FROM "vuln_app_info" GROUP BY "vuln_app_info"."gender" LIMIT 1 OFFSET 1 --
```

<div align=center><img src="./images/10.png"></div>


# CVE-2021-35042
## Vulnerability Introduction
Django 3.1.x before 3.1.13 and 3.2.x before 3.2.5 allows QuerySet.order_by SQL injection if order_by is untrusted input from a client of a web application.

<div align=center><img src="./images/11.png"></div>

## Vulnerability Environment
 - Reference for a well-built environment [CVE-2021-35042](https://github.com/H3rmesk1t/Django-SQL-Inject-Env/tree/main/CVE-2021-35042).

## Vulnerability Analysis
According to the vulnerability information, follow up on the `order_by` function. The function first calls the `clear_ordering` function to clear the `self.order_by` parameter in the `Query` class, and then call the `add_ordering` function to add the `self.order_by` parameter.

<div align=center><img src="./images/12.png"></div>

The parameters passed through the `order_by` function are arrays. The `SQL` statement corresponding to the code that receives parameters in the vulnerable environment is as follows:

```python
query = request.GET.get('order_by', default='vuln')
res = User.objects.order_by(query)
```

````sql
SELECT "app_user"."vuln", "app_user"."order_by" FROM "app_user" ORDER BY "app_user"."order_by" ASC, "app_user"."vuln" ASC
```

Follow up on the `add_ordering` function, which makes a judgment after recursively `ordering`. If `item` is a string, then continue to make the following five judgments:
 - `if '.' in item`: Judgment
Whether it is a query with columns, the SQL statement allows columns that formulate table names, such as `order by (user.name)`, that is, sort according to the `name` field under the `user` table. This method will be deleted after `Django 4.0`, so after the judgment is successful, use the `warning` warning, and then `continue`.
 - `if item == '?'`: When the value of `item` is the string`?`, the value of `order by` is set to `RAND()`, indicating that the return data of `SQL` syntax is displayed randomly, and then `continue` is performed.
 - `if item.startswith('-')`: When the start of `item` is a string `-`, the result of the `order by` query is connected to `DESC`, indicating descending order sorting. The default string will be followed by `ASC` positive order sorting, and the `-` symbol at the beginning is removed.
 - `if item in self.annotations`: When judging, it contains annotation identifier, if there is one, it is directly `continue`.
 - `if self.extra and item in self.extra`: To determine whether there is any additional addition, if there is, directly `continue`.

After five judgments, enter the `self.names_to_path(item.split(LOOKUP_SEP), self.model._meta)` function to determine whether the current `item` is a valid column name, and then pass all `ordering` into the `self.order_by` parameter in the `Query` class for subsequent processing.

<div align=center><img src="./images/13.png"></div>

In the first judgment, `if '.' in item` judgement can ensure that the `order by` query can be better compatible with what kind of column-based query, but after judging whether it is a table query, if it is a table query, `continue` is performed, and `continue` directly skips the validity check of the column of `self.names_to_path`. Follow up on the code with string `.`, and the `get_order_by` function in the file `django/db/models/sql/compiler.py`, the core code is as follows:

```python
if '.' in field:
    table, col = col.split('.', 1)
    order_by.append((
            OrderBy(
                RawSQL('%s.%s' % (self.quote_name_unless_alias(table), col), []),
                descending=descending
            ), False))
    Continue continue
```

In the above code, the function `self.quote_name_unless_alias` handles table names, and also uses dictionaries to force filter valid table names. The subsequent columns happen to be unfiltered, so you can construct a closed statement for `SQL` injection.

Parameter `app_user.name) --`The final statement passed to the database is:

````sql
SELECT `app_user`.`id`, `app_user`.`name` FROM `app_user` ORDER BY (`app_user`.name) --) ASC LIMIT 21
```

Use the close bracket `)` to perform stack injection, and the basic `payload` is as follows: `http://127.0.0.1:8000/vuln/?order_by=vuln_app_user.name); select%20updatexml(1,%20concat(0x7e,(select%20@@version)),1)%23`

<div align=center><img src="./images/14.png"></div>


# CVE-2022-28346
## Vulnerability Introduction
An issue was discovered in Django 2.2 before 2.2.28, 3.2 before 3.2.13, and 4.0 before 4.0.4. QuerySet.annotate(), aggregate(), and extra() methods are subject to SQL injection in column aliases via a crafted dictionary (with dictionary expansion) as the passed **kwargs.

<div align=center><img src="./images/15.png"></div>

## Vulnerability Environment
 - Reference for a well-built environment [CVE-2022-28346](https://github.com/H3rmesk1t/Django-SQL-Inject-Env/tree/main/CVE-2022-28346).

## Vulnerability Analysis
Find the `commit` record of `Django`, and you can see the test cases in the official fix code.

<div align=center><img src="./images/16.png"></div>

If the vulnerability is described, follow up on the vulnerability point `annotate` function. In the `annotate` function, first call `_annotate` and pass in `kwargs`.

<div align=center><img src="./images/17.png"></div>

After completing a series of operations such as `kwargs.values()` legitimacy verification, the `kwargs` is updated to `annotations`, and then traverse the elements in `annotations` and call `add_annotation` for data aggregation.

<div align=center><img src="./images/18.png"></div>

Follow up on the `add_annotation` function and continue to call the `resolve_expression` parse expression. There is no corresponding check for the passed aggregation parameters here.

<div align=center><img src="./images/19.png"></div>

Continue to follow up and finally enter `db.models.sql.query.py:resolve_ref`, `resolve_ref` will get the elements in `annotations`, convert them and bring them into the query conditions, and finally the result is aggregated into a `Col` object through `transform_function`.

<div align=center><img src="./images/20.png"></div>

Next, return to `db.models.query.py:_annotate`, execute the `sql` statement, and return the result to `QuerySet` for display.

<div align=center><img src="./images/21.png"></div>

# refer to
 - [CVE-2020-7471 Detailed Vulnerability Analysis Principles and POC](https://xz.aliyun.com/t/7218#toc-3)
 - [Django CVE-2021-35042 order_by SQL injection analysis](https://xz.aliyun.com/t/9834#toc-4)
 - [Django security releases issued: 4.0.4, 3.2.13, and 2.2.28](https://www.djangoproject.com/weblog/2022/apr/11/security-releases/)